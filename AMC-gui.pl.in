#! /usr/bin/perl -w
#
# Copyright (C) 2008-2011 Alexis Bienvenue <paamc@passoire.fr>
#
# This file is part of Auto-Multiple-Choice
#
# Auto-Multiple-Choice is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 2 of
# the License, or (at your option) any later version.
#
# Auto-Multiple-Choice is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Auto-Multiple-Choice.  If not, see
# <http://www.gnu.org/licenses/>.

use Getopt::Long;

use Gtk2 -init;
use Gtk2::GladeXML;
use XML::Simple;
use IO::File;
use IO::Select;
use POSIX qw/strftime/;
use Time::Local;
use File::Spec::Functions qw/splitpath catpath splitdir catdir catfile rel2abs tmpdir/;
use File::Temp qw/ tempfile tempdir /;
use File::Copy;
use File::Path qw/remove_tree/;
use Archive::Tar;
use Archive::Tar::File;
use Encode;
use I18N::Langinfo qw(langinfo CODESET);
use Locale::Language;

use Module::Load;
use Module::Load::Conditional qw/check_install/;

use AMC::Basic;
use AMC::State;
use AMC::MEPList;
use AMC::ANList;
use AMC::Gui::Manuel;
use AMC::Gui::Association;
use AMC::Gui::Commande;
use AMC::Gui::Notes;
use AMC::Gui::Zooms;

use Data::Dumper;

use constant {
    DOC_TITRE => 0,
    DOC_MAJ => 1,

    MEP_PAGE => 0,
    MEP_ID => 1,
    MEP_MAJ => 2,

    DIAG_ID => 0,
    DIAG_ID_BACK => 1,
    DIAG_MAJ => 2,
    DIAG_EQM => 3,
    DIAG_EQM_BACK => 4,
    DIAG_DELTA => 5,
    DIAG_DELTA_BACK => 6,

    INCONNU_SCAN => 0,
    INCONNU_ID => 1,

    PROJ_NOM => 0,
    PROJ_ICO => 1,

    CORREC_ID => 0,
    CORREC_MAJ => 1,
    CORREC_FILE => 2,

    COMBO_ID => 1,
    COMBO_TEXT => 0,

    MODEL_NOM => 0,
    MODEL_PATH => 1,
    MODEL_DESC => 2,

    COPIE_N => 0,

    TEMPLATE_FILES_PATH => 0,
    TEMPLATE_FILES_FILE => 1,
};

Gtk2::IconTheme->get_default->prepend_search_path(amc_specdir('icons'));
Gtk2::Window->set_default_icon_list(map { Gtk2::IconTheme->get_default->load_icon("auto-multiple-choice",$_,"force-svg") } (8,16,32,48,64,128));

use_gettext;

my $debug=0;
my $debug_file='';

my $profile='';

GetOptions("debug!"=>\$debug,
	   "debug-file=s"=>\$debug_file,
	   "profile=s"=>\$profile,
	   );

if($debug_file) {
    my $date=strftime("%c",localtime());
    open(DBG,">>",$debug_file);
    print DBG "\n\n".('#' x 40)."\n# DEBUG - $date\n".('#' x 40)."\n\n";
    close(DBG);
    $debug=$debug_file;
}

if($debug) {
    set_debug($debug);
    debug "DEBUG MODE";
    print "DEBUG ==> ".AMC::Basic::debug_file()."\n";
}

debug_pm_version("Gtk2");
debug_pm_version("Gtk2::GladeXML");

my $glade_xml=__FILE__;
$glade_xml =~ s/\.p[ml]$/.glade/i;

my $home_dir=Glib::get_home_dir();

my $o_file='';
my $o_dir=$home_dir.'/.AMC.d';
my $state_file="$o_dir/state.xml";

# Gets system encoding
my $encodage_systeme=langinfo(CODESET());
$encodage_systeme='UTF-8' if(!$encodage_systeme);

sub hex_color {
    my $s=shift;
    return(Gtk2::Gdk::Color->parse($s)->to_string());
}

my %w=();

# Default general options, to be used when not set in the main options
# file

my %o_defaut=('pdf_viewer'=>['commande',
			     'evince','acroread','gpdf','okular','xpdf',
			     ],
	      'img_viewer'=>['commande',
			     'eog','ristretto','gpicview','mirage','gwenview',
			     ],
	      'csv_viewer'=>['commande',
			     'gnumeric','kspread','libreoffice','localc','oocalc',
			     ],
	      'ods_viewer'=>['commande',
			     'libreoffice','localc','oocalc',
			     ],
	      'xml_viewer'=>['commande',
			     'gedit','kedit','kwrite','mousepad',
			     ],
	      'tex_editor'=>['commande',
			     'texmaker','kile','emacs','gedit','kedit','kwrite','mousepad',
			     ],
	      'txt_editor'=>['commande',
			     'gedit','kedit','kwrite','mousepad','emacs',
			     ],
	      'html_browser'=>['commande',
			       'sensible-browser %u','firefox %u','galeon %u','konqueror %u','dillo %u',
			       ],
	      'dir_opener'=>['commande',
			     'nautilus --no-desktop file://%d',
			     'Thunar %d',
			     'konqueror file://%d',
			     'dolphin %d',
			     ],
	      'print_command_pdf'=>['commande',
				    'cupsdoprint %f','lpr %f',
				    ],
# TRANSLATORS: directory name for projects. Please use only alphanumeric characters, and - or _. No accentuated characters.
	      'rep_projets'=>$home_dir.'/'.__"MC-Projects",
	      'rep_modeles'=>$o_dir."/Models",
	      'seuil_eqm'=>3.0,
	      'seuil_sens'=>8.0,
	      'saisie_dpi'=>150,
	      'vector_scan_density'=>250,
	      'n_procs'=>0,
	      'delimiteur_decimal'=>',',
	      'defaut_encodage_liste'=>'UTF-8',
	      'encodage_interne'=>'UTF-8',
	      'defaut_encodage_csv'=>'UTF-8',
	      'encodage_latex'=>'',
	      'defaut_moteur_latex_b'=>'pdflatex',
	      'defaut_seuil'=>0.15,
	      'taille_max_correction'=>'1000x1500',
	      'qualite_correction'=>'150',
	      'conserve_taille'=>1,
	      'methode_impression'=>'CUPS',
	      'imprimante'=>'',
	      'options_impression'=>{'sides'=>'two-sided-long-edge',
				     'number-up'=>1,
				     'repertoire'=>'/tmp',
				     },
	      'manuel_image_type'=>'xpm',
	      'assoc_ncols'=>4,
	      'tolerance_marque_inf'=>0.2,
	      'tolerance_marque_sup'=>0.2,

	      'symboles_trait'=>2,
	      'symboles_indicatives'=>'',
	      'symbole_0_0_type'=>'none',
	      'symbole_0_0_color'=>hex_color('black'),
	      'symbole_0_1_type'=>'circle',
	      'symbole_0_1_color'=>hex_color('red'),
	      'symbole_1_0_type'=>'mark',
	      'symbole_1_0_color'=>hex_color('red'),
	      'symbole_1_1_type'=>'mark',
	      'symbole_1_1_color'=>hex_color('blue'),
	      
	      'annote_ps_nl'=>60,
	      'annote_ecart'=>5.5,
	      'annote_chsign'=>4,

	      'defaut_annote_rtl'=>'',
	      'defaut_verdict'=>"%(ID)\n".__("Mark: %s/%m (total score: %S/%M)"),
	      'defaut_verdict_q'=>"\"%"."s/%"."m\"",

	      'zoom_window_height'=>400,
	      'zoom_window_factor'=>1.0,
	      );

# MacOSX universal command to open files or directories : /usr/bin/open
if(lc($^O) eq 'darwin') {
    for my $k (qw/pdf_viewer img_viewer csv_viewer ods_viewer xml_viewer tex_editor txt_editor dir_opener/) {
	$o_defaut{$k}=['commande','/usr/bin/open','open'];
    }
    $o_defaut{'html_browser'}=['commande','/usr/bin/open %u','open %u'];
}

# Default options for projects

my %projet_defaut=('texsrc'=>'',
		   'mep'=>'mep',
		   'cr'=>'cr',
		   'listeetudiants'=>'',
		   'notes'=>'notes.xml',
		   'seuil'=>'',
		   'encodage_csv'=>'',
		   'encodage_liste'=>'',
		   'maj_bareme'=>1,
		   'fichbareme'=>'bareme.xml',
		   'docs'=>['DOC-sujet.pdf','DOC-corrige.pdf','DOC-calage.xy'],
		   
		   'modele_regroupement'=>'',
		   'regroupement_compose'=>'',

		   'note_min'=>'',
		   'note_max'=>20,
		   'note_max_plafond'=>1,
		   'note_grain'=>"0.5",
		   'note_arrondi'=>'inf',

		   'liste_key'=>'',
		   'association'=>'association.xml',
		   'assoc_code'=>'',

		   'moteur_latex_b'=>'',

		   'nom_examen'=>'',
		   'code_examen'=>'',

		   'nombre_copies'=>0,
	    
		   '_modifie'=>1,
		   '_modifie_ok'=>0,
		   
		   'format_export'=>'CSV',
		   'export_csv_separateur'=>",",
		   'export_csv_cochees'=>'',
		   'after_export'=>'file',
		   'export_include_abs'=>'',
		   'export_ncols'=>2,
		   'export_pagesize'=>'a4',

		   'annote_position'=>'marge',

		   'verdict'=>'',
		   'verdict_q'=>'',
		   'annote_rtl'=>'',

		   'export_sort'=>'n',
		   );

my $mep_saved='mep.storable';
my $an_saved='an.storable';

my %o=();
my %state=();

# Test whether all commands defined to open/view files are
# reachable. If not, the user is warned...

sub test_commandes {
    my ($dont_warn)=@_;
    my @pasbon=();
    my @missing=();
    for my $c (grep { /_(viewer|editor|opener)$/ } keys(%o)) {
	my $nc=$o{$c};
	$nc =~ s/\s.*//;
	if(!commande_accessible($nc)) {
	    debug "Missing command [$c]: $nc";
	    push @missing,$c;
	    push @pasbon,$nc;
	}
    }
    if(@pasbon && !$dont_warn) {
	my $dialog = Gtk2::MessageDialog
	    ->new_with_markup($w{'main_window'},
			      'destroy-with-parent',
			      'warning','ok',
			      __("Some commands allowing to open documents can't be found:")
			      ." ".join(", ",map { "<b>$_</b>"; } @pasbon).". "
			      .__("Please check its correct spelling and install missing software.")." "
			      .sprintf(__"You can change used commands following <i>%s</i> from menu <i>%s</i>.",
# TRANSLATORS: "Preferences" menu
				       __"Preferences",
# TRANSLATORS: "Edit" menu
				       __"Edit"));
	$dialog->run;
	$dialog->destroy;
    }
    return(@missing);
}

# Creates general options directory if not present

if(! -d $o_dir) {
    mkdir($o_dir) or die "Error creating $o_dir : $!";

    # gets older verions (<=0.254) main configuration file and move it
    # to the new location

    if(-f $home_dir.'/.AMC.xml') {
	debug "Moving old configuration file";
	move($home_dir.'/.AMC.xml',$o_dir."/cf.default.xml");
    }
}

# Read/write options XML files

sub pref_xx_lit {
    my ($fichier)=@_;
    if((! -f $fichier) || -z $fichier) {
	return();
    } else {
	return(%{XMLin($fichier,SuppressEmpty => '')});
    }
}

sub pref_xx_ecrit {
    my ($data,$key,$fichier)=@_;
    if(open my $fh,">:encoding(utf-8)",$fichier) {
	XMLout($data,
	       "XMLDecl"=>'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>',
	       "RootName"=>$key,'NoAttr'=>1,
	       "OutputFile" => $fh,
	       );
	close $fh;
	return(0);
    } else {
	return(1);
    }
}

# Read/write running state

sub sauve_state {
    if($state{'_modifie'} || $state{'_modifie_ok'}) {
	debug "Saving state...";
	
	if(pref_xx_ecrit(\%state,'AMCState',$state_file)) {
	    my $dialog = Gtk2::MessageDialog
		->new($w{'main_window'},
		      'destroy-with-parent',
		      'error','ok',
		      __"Error writing state file %s : %s",
		      $state_file,$!);
	    $dialog->run;
	    $dialog->destroy;      
	} else {
	    $state{'_modifie'}=0;
	    $state{'_modifie_ok'}=0;
	}
    }
}

# annulation apprentissage

sub annule_apprentissage {
    my $dialog = Gtk2::MessageDialog
	->new_with_markup($w{'main_window'},
			  'destroy-with-parent',
			  'question','yes-no',
			  __("Several dialogs try to help you be at ease handling AMC.")." ".
			  sprintf(__"Unless you tick the \"%s\" box, they are shown only once.",__"Show this message again next time")." ".
			  __"Do you want to forgot which dialogs you have already seen and ask to show all of them next time they should appear ?"
			  );
    my $reponse=$dialog->run;
    $dialog->destroy;      
    if($reponse eq 'yes') {
	debug "Clearing learning states...";
	$state{'apprentissage'}={};
	$state{'_modifie'}=1;
	sauve_state();
    }
}

# Read the state file

if(-r $state_file) {
    %state=pref_xx_lit($state_file);
    $state{'apprentissage'}={} if(!$state{'apprentissage'});
}

$state{'_modifie'}=0;
$state{'_modifie_ok'}=0;

# gets the last used profile

if(!$state{'profile'}) {
    $state{'profile'}='default';
    $state{'_modifie'}=1;
}

# sets new profile if given as a command argument

if($profile && $profile ne $state{'profile'}) {
    $state{'profile'}=$profile;
    $state{'_modifie'}=1;
}

sauve_state();

debug "Profile : $state{'profile'}";

$o_file=$o_dir."/cf.".$state{'profile'}.".xml";

# Read general options ...

if(-r $o_file) {
    %o=pref_xx_lit($o_file);
}

sub set_option_to_default {
    my ($key,$subkey,$force)=@_;
    if($subkey) {
	if($force || ! exists($o{$key}->{$subkey})) {
	    $o{$key}->{$subkey}=$o_defaut{$key}->{$subkey};
	    debug "New sub-global parameter : $key/$subkey = $o{$key}->{$subkey}";
	}
    } else {
	if($force || ! exists($o{$key})) {
	    # set to default
	    if(ref($o_defaut{$key}) eq 'ARRAY') {
		my ($type,@valeurs)=@{$o_defaut{$key}};
		if($type eq 'commande') {
		  UC: for my $c (@valeurs) {
		      if(commande_accessible($c)) {
			  $o{$key}=$c;
			  last UC;
		      }
		  }
		    if(!$o{$key}) {
			debug "No available command for option $key: using the first one";
			$o{$key}=$valeurs[0];
		    }
		} else {
		    debug "ERR: unknown option type : $type";
		}
	    } elsif(ref($o_defaut{$key}) eq 'HASH') {
		$o{$key}={%{$o_defaut{$key}}};
	    } else {
		$o{$key}=$o_defaut{$key};
		$o{$key}=$encodage_systeme if($key =~ /^encodage_/ && !$o{$key});
	    }
	    debug "New global parameter : $key = $o{$key}" if($o{$key});
	} else {
	    # already defined option: go with sub-options if any
	    if(ref($o_defaut{$key}) eq 'HASH') {
		for my $kk (keys %{$o_defaut{$key}}) {
		    set_option_to_default($key,$kk,$force);
		}
	    }
	}
    }
}

# sets undefined options to default value

for my $k (keys %o_defaut) {
    set_option_to_default($k);
}

# for unexisting commands options, see if we can find an available one
# from the default list

for my $k (test_commandes(1)) {
    set_option_to_default($k,'','FORCE');
}

# Clears modified flag for the options

$o{'_modifie'}=0;
$o{'_modifie_ok'}=0;

# some options were renamed to defaut_* between 0.226 and 0.227

for(qw/encodage_liste encodage_csv/) {
    if($o{"$_"} && ! $o{"defaut_$_"}) {
	$o{"defaut_$_"}=$o{"$_"};
	$o{'_modifie'}=1;
    }
}

# Replace old (pre 0.280) rep_modeles value with new one

if($o{'rep_modeles'} eq '/usr/share/doc/auto-multiple-choice/exemples') {
    $o{'rep_modeles'}=$o_defaut{'rep_modeles'};
    $o{'_modifie'}=1;
}

# Internal encoding _must_ be UTF-8, for XML::Writer (used by
# AMC::Gui::Association for example) to work
if($o{'encodage_interne'} ne 'UTF-8') {
    $o{'encodage_interne'}='UTF-8';
    $o{'_modifie'}=1;
}

# creates projets and models directories if needed (if not present,
# Edit/Parameters can be disrupted)

mkdir($o{'rep_projets'}) if(! -d $o{'rep_projets'});
mkdir($o{'rep_modeles'}) if(! -d $o{'rep_modeles'});
    
#############################################################################

my %projet=();

sub bon_encodage {
    my ($type)=@_;
    return($projet{'options'}->{"encodage_$type"}
	   || $o{"defaut_encodage_$type"}
	   || $o{"encodage_$type"}
	   || $o_defaut{"defaut_encodage_$type"}
	   || $o_defaut{"encodage_$type"}
	   || "UTF-8");
}

sub raccourcis {
    my ($proj)=@_;
    my %pathes=('%PROJETS'=>$o{'rep_projets'},
		'%HOME',$home_dir,
		''=>'%PROJETS',
	);
    $proj=$projet{'nom'} if(!$proj);
    if($proj) {
	$pathes{'%PROJET'}=$o{'rep_projets'}."/".$proj;
	$pathes{''}='%PROJET';
    }
    return(\%pathes);
}

sub absolu {
    my ($f,$proj)=@_;
    return($f) if(!defined($f));
    return(proj2abs(raccourcis($proj),$f));
}

sub relatif {
    my ($f,$proj)=@_;
    return($f) if(!defined($f));
    return(abs2proj(raccourcis($proj),$f));
}

sub id2file {
    my ($id,$prefix,$extension)=(@_);
    $id =~ s/\+//g;
    $id =~ s/\//-/g;
    return(absolu($projet{'options'}->{'cr'})."/$prefix-$id.$extension");
}

sub is_local {
    my ($f,$proj)=@_;
    my $prefix=$o{'rep_projets'}."/";
    $prefix .= $projet{'nom'}."/" if($proj);
    if(defined($f)) {
	return($f !~ /^[\/%]/ 
	       || $f =~ /^$prefix/
	       || $f =~ /[\%]PROJET\//);
    } else {
	return('');
    }
}

sub fich_options {
    my $nom=shift;
    return $o{'rep_projets'}."/$nom/options.xml";
}

sub moteur_latex {
    my $m=$projet{'options'}->{'moteur_latex_b'};
    $m=$o{'defaut_moteur_latex_b'} if(!$m);
    $m=$o_defaut{'defaut_moteur_latex_b'} if(!$m);
    return($m);
}

my $gui=Gtk2::GladeXML->new($glade_xml,'main_window','auto-multiple-choice');

for(qw/onglets_projet preparation_etats documents_tree main_window
    mep_tree edition_latex
    onglet_notation onglet_saisie
    log_general commande avancement annulation button_mep_warnings
    liste_filename liste_path liste_edit liste_setfile liste_refresh
    doc_menu menu_debug menu_outils
    liste diag_tree inconnu_tree diag_result
    maj_bareme correc_tree correction_result regroupement_corriges
    options_CSV options_ods options_List
    /) {
    $w{$_}=$gui->get_widget($_);
}

# Grid lines are not well-positioned in RTL environments, I don't know
# why... so I remove them.
if($w{'main_window'}->get_direction() eq 'rtl') {
    debug "RTL mode: removing vertical grids";
    for(qw/documents mep diag inconnu/) {
	my $w=$gui->get_widget($_.'_tree');
	$w->set_grid_lines('horizontal') if($w);
    }
}

$w{'commande'}->hide();

sub debug_set {
    $debug=$w{'menu_debug'}->get_active;
    debug "DEBUG MODE : OFF" if(!$debug);
    set_debug($debug);
    if($debug) {
	debug "DEBUG MODE : ON";

	my $dialog = Gtk2::MessageDialog
	    ->new($w{'main_window'},
		  'destroy-with-parent',
		  'info','ok',
		  __("Debugging mode.")." "
		  .sprintf(__"Debugging informations will be written in file %s.",AMC::Basic::debug_file()));
	$dialog->run;
	$dialog->destroy;
    }
}

$w{'menu_debug'}->set_active($debug);

# add doc list menu

my $docs_menu=Gtk2::Menu->new();

my @doc_langs=();

my $hdocdir=amc_specdir('doc/auto-multiple-choice')."/html/";
if(opendir(DOD,$hdocdir)) {
    push @doc_langs,map { s/auto-multiple-choice\.//;$_; } grep { /auto-multiple-choice\...(_..)?/ } readdir(DOD);
    closedir(DOD);
} else {
    debug("DOCUMENTATION : Can't open directory $hdocdir: $!");
}

my %ltext_loc=('French'=>__"French",
	       'English'=>__"English",
	       );

for my $l (@doc_langs) {
    my $ltext;
    $ltext=code2language($l);
    $ltext=$l if(! $ltext);
    $ltext=$ltext_loc{$ltext} if($ltext_loc{$ltext});
    my $m=Gtk2::ImageMenuItem->new_with_label($ltext);
    my $it=Gtk2::IconTheme->new();
    my ($taille,undef)=Gtk2::IconSize->lookup('menu');
    $it->prepend_search_path($hdocdir."auto-multiple-choice.$l");
    my $ii=$it->lookup_icon("flag",$taille ,"force-svg");
    if($ii) {
	$m->set_image(Gtk2::Image->new_from_pixbuf($it->load_icon("flag",$taille ,"force-svg")));
    }
    $m->signal_connect("activate",\&activate_doc,$l);
    $docs_menu->append($m);
}

$docs_menu->show_all();

$w{'doc_menu'}->set_submenu($docs_menu);

###

sub dialogue_apprentissage {
    my ($key,$type,$buttons,@oo)=@_;
    my $resp='';
    $type='info' if(!$type);
    $buttons='ok' if(!$buttons);
    if(!$state{'apprentissage'}->{$key}) {
	my $dialog = Gtk2::MessageDialog
	    ->new_with_markup($w{'main_window'},
			      'destroy-with-parent',
			      $type,$buttons,
			      @oo);

	my $garde=Gtk2::CheckButton->new(__"Show this message again next time");
	$garde->set_active(0);
	$garde->can_focus(0);

	$dialog->get_content_area()->add($garde);
	$dialog->show_all();
	
	$resp=$dialog->run;

	if(!$garde->get_active()) {
	    debug "Learning : $key";
	    $state{'apprentissage'}->{$key}=1;
	    $state{'_modifie'}=1;
	    sauve_state();
	}

	$dialog->destroy;
    }
    return($resp);
}

### modele documents

my $doc_store = Gtk2::ListStore->new ('Glib::String', 
				      'Glib::String');

my @doc_ligne=($doc_store->append,$doc_store->append,$doc_store->append);

$doc_store->set($doc_ligne[0],DOC_TITRE,__"question",DOC_MAJ,'');
$doc_store->set($doc_ligne[1],DOC_TITRE,__"solution",DOC_MAJ,'');
$doc_store->set($doc_ligne[2],DOC_TITRE,__"adjustment",DOC_MAJ,'');
$w{'documents_tree'}->set_model($doc_store);

my $renderer;
my $column;

$renderer=Gtk2::CellRendererText->new;
$column = Gtk2::TreeViewColumn->new_with_attributes (__"document",
						     $renderer,
						     text=> DOC_TITRE);
$w{'documents_tree'}->append_column ($column);

$renderer=Gtk2::CellRendererText->new;
# TRANSLATORS: document state, in short (exists or not, last change date)
$column = Gtk2::TreeViewColumn->new_with_attributes (__"state",
						     $renderer,
						     text=> DOC_MAJ);
$w{'documents_tree'}->append_column ($column);

### modele MEP

my $mep_store = Gtk2::ListStore->new ('Glib::String',
				      'Glib::String', 
				      'Glib::String');

$w{'mep_tree'}->set_model($mep_store);

$renderer=Gtk2::CellRendererText->new;
# TRANSLATORS: (in short)
$column = Gtk2::TreeViewColumn->new_with_attributes (__"page",
						     $renderer,
						     text=> MEP_PAGE);
$w{'mep_tree'}->append_column ($column);

$renderer=Gtk2::CellRendererText->new;
# TRANSLATORS: identification code for a page (in short)
$column = Gtk2::TreeViewColumn->new_with_attributes (__"ID",
						     $renderer,
						     text=> MEP_ID);
$w{'mep_tree'}->append_column ($column);

$renderer=Gtk2::CellRendererText->new;
# TRANSLATORS: last modification date (in short)
$column = Gtk2::TreeViewColumn->new_with_attributes (__"Updated",
						     $renderer,
						     text=> MEP_MAJ);
$w{'mep_tree'}->append_column ($column);

### COPIES

my $copies_store = Gtk2::ListStore->new ('Glib::String');

### FILES FOR TEMPLATE

my $template_files_store = Gtk2::TreeStore->new ('Glib::String',
						 'Glib::String');

### modele CORREC

my $correc_store = Gtk2::ListStore->new ('Glib::String',
					 'Glib::String', 
					 'Glib::String', 
					 );

$w{'correc_tree'}->set_model($correc_store);

$renderer=Gtk2::CellRendererText->new;
$column = Gtk2::TreeViewColumn->new_with_attributes (__"ID",
						     $renderer,
						     text=> CORREC_ID);
$w{'correc_tree'}->append_column ($column);

$renderer=Gtk2::CellRendererText->new;
$column = Gtk2::TreeViewColumn->new_with_attributes (__"Updated",
						     $renderer,
						     text=> CORREC_MAJ);
$w{'correc_tree'}->append_column ($column);

### modele DIAGNOSTIQUE SAISIE

my $diag_store = Gtk2::ListStore->new ('Glib::String',
				       'Glib::String', 
				       'Glib::String', 
				       'Glib::String', 
				       'Glib::String', 
				       'Glib::String', 
				       'Glib::String');

$w{'diag_tree'}->set_model($diag_store);

$renderer=Gtk2::CellRendererText->new;
$column = Gtk2::TreeViewColumn->new_with_attributes (__"identifier",
						     $renderer,
						     text=> DIAG_ID,
						     'background'=> DIAG_ID_BACK);
$column->set_sort_column_id(DIAG_ID);
$w{'diag_tree'}->append_column ($column);

$renderer=Gtk2::CellRendererText->new;
$column = Gtk2::TreeViewColumn->new_with_attributes (__"updated",
						     $renderer,
						     text=> DIAG_MAJ);
$w{'diag_tree'}->append_column ($column);

$renderer=Gtk2::CellRendererText->new;
# TRANSLATORS: mean square error distance (in short)
$column = Gtk2::TreeViewColumn->new_with_attributes (__"MSE",
						     $renderer,
						     'text'=> DIAG_EQM,
						     'background'=> DIAG_EQM_BACK);
$column->set_sort_column_id(DIAG_EQM);
$w{'diag_tree'}->append_column ($column);

$renderer=Gtk2::CellRendererText->new;
$column = Gtk2::TreeViewColumn->new_with_attributes (__"sensitivity",
						     $renderer,
						     'text'=> DIAG_DELTA,
						     'background'=> DIAG_DELTA_BACK);
$column->set_sort_column_id(DIAG_DELTA);
$w{'diag_tree'}->append_column ($column);

### modeles combobox

sub cb_model {
    my @texte=(@_);
    my $cs=Gtk2::ListStore->new ('Glib::String','Glib::String');
    my $k;
    my $t;
    while(($k,$t)=splice(@texte,0,2)) {
	$cs->set($cs->append,
		 COMBO_ID,$k,
		 COMBO_TEXT,$t);
    }
    return($cs);
}

# rajouter a partir de Encode::Supported
# TRANSLATORS: for encodings
my $encodages=[{qw/inputenc latin1 iso ISO-8859-1/,'txt'=>'ISO-8859-1 ('.__("Western Europe").')'},
# TRANSLATORS: for encodings
	       {qw/inputenc latin2 iso ISO-8859-2/,'txt'=>'ISO-8859-2 ('.__("Central Europe").')'},
# TRANSLATORS: for encodings
	       {qw/inputenc latin3 iso ISO-8859-3/,'txt'=>'ISO-8859-3 ('.__("Southern Europe").')'},
# TRANSLATORS: for encodings
	       {qw/inputenc latin4 iso ISO-8859-4/,'txt'=>'ISO-8859-4 ('.__("Northern Europe").')'},
# TRANSLATORS: for encodings
	       {qw/inputenc latin5 iso ISO-8859-5/,'txt'=>'ISO-8859-5 ('.__("Cyrillic").')'},
# TRANSLATORS: for encodings
	       {qw/inputenc latin9 iso ISO-8859-9/,'txt'=>'ISO-8859-9 ('.__("Turkish").')'},
# TRANSLATORS: for encodings
	       {qw/inputenc latin10 iso ISO-8859-10/,'txt'=>'ISO-8859-10 ('.__("Northern").')'},
# TRANSLATORS: for encodings
	       {qw/inputenc utf8x iso UTF-8/,'txt'=>'UTF-8 ('.__("Unicode").')'},
	       {qw/inputenc cp1252 iso cp1252/,'txt'=>'Windows-1252',
		alias=>['Windows-1252','Windows']},
	       {qw/inputenc applemac iso MacRoman/,'txt'=>'Macintosh '.__"Western Europe"},
	       {qw/inputenc macce iso MacCentralEurRoman/,'txt'=>'Macintosh '.__"Central Europe"},
	       ];

sub get_enc {
    my ($txt)=@_;
    for my $e (@$encodages) {
	return($e) if($e->{'inputenc'} =~ /^$txt$/i ||
		      $e->{'iso'} =~ /^$txt$/i);
	if($e->{'alias'}) {
	    for my $a (@{$e->{'alias'}}) {
		return($e) if($a =~ /^$txt$/i);
	    }
	}
    }
    return('');
}

my %formats_noms=(
		  'CSV'=>'CSV',
		  'ods'=>'OpenOffice',
		  'List'=>__("PDF list"),
		  );

# TRANSLATORS: you can omit the [...] part, just here to explain context
my $cb_model_vide_key=cb_model(''=>__p"(none) [No primary key found in association list]");
# TRANSLATORS: you can omit the [...] part, just here to explain context
my $cb_model_vide_code=cb_model(''=>__p"(none) [No code found in LaTeX file]");

my %cb_stores=(
    'delimiteur_decimal'=>cb_model(',',__", (comma)",
				   '.',__". (dot)"),
# TRANSLATORS: rounding method for marks
    'note_arrondi'=>cb_model('inf',__"floor",
# TRANSLATORS: rounding method for marks
			     'normal',__"rounding",
# TRANSLATORS: rounding method for marks
			     'sup',__"ceiling"),
    'methode_impression'=>cb_model('CUPS','CUPS',
# TRANSLATORS: printing method
				   'commande',__"command",
# TRANSLATORS: printing method
				   'file'=>__"to files"),
# TRANSLATORS: you can omit the [...] part, just here to explain context
    'sides'=>cb_model('one-sided',__p("one sided [No two-sided printing]"),
# TRANSLATORS: two-side printing type
		      'two-sided-long-edge',__"long edge",
# TRANSLATORS: two-side printing type
		      'two-sided-short-edge',__"short edge"),
    'encodage_latex'=>cb_model(map { $_->{'iso'}=>$_->{'txt'} }
			       (@$encodages)),
# TRANSLATORS: you can omit the [...] part, just here to explain context
    'manuel_image_type'=>cb_model('ppm'=>__p("(none) [No transitional image type (direct processing)]"),
				  'xpm'=>'XPM',
				  'gif'=>'GIF'),
    'liste_key'=>$cb_model_vide_key,
    'assoc_code'=>$cb_model_vide_code,
    'format_export'=>cb_model(%formats_noms),
    'after_export'=>cb_model(""=>__"that's all",
			     "file"=>__"open the file",
			     "dir"=>__"open the directory",
    ),
    'export_csv_separateur'=>cb_model("TAB"=>'<TAB>',
				      ";"=>";",
				      ","=>","),
# TRANSLATORS: you can omit the [...] part, just here to explain context
    'annote_position'=>cb_model("none"=>__p("(none) [No annotation position (do not write anything)]"),
				"marge"=>__"margin",
				"case"=>__"near boxes",
    ),
    'export_sort'=>cb_model("n"=>__"name",
			    "i"=>__"sheet number",
			    "l"=>__"line in students list",
# TRANSLATORS: you can omit the [...] part, just here to explain context
			    "m"=>__p("mark [student mark, for sorting]"),
			    ),
    'export_pagesize'=>cb_model("a3"=>"A3",
				"a4"=>"A4",
				"letter"=>"Letter",
				"legal"=>"Legal",
    ),
    );


my $symbole_type_cb=cb_model("none"=>__"mothing",
			     "circle"=>__"circle",
			     "mark"=>__"mark",
			     "box"=>__"box",
			     );

for my $k (qw/0_0 0_1 1_0 1_1/) {
    $cb_stores{"symbole_".$k."_type"}=$symbole_type_cb;
}

my %extension_fichier=('List'=>'pdf');

$diag_store->set_sort_func(DIAG_EQM,\&sort_num,DIAG_EQM);
$diag_store->set_sort_func(DIAG_DELTA,\&sort_num,DIAG_DELTA);

### export

sub maj_export {
    my $old_format=$projet{'options'}->{'format_export'};
    reprend_pref('export',$projet{'options'});

    debug "Format : ".$projet{'options'}->{'format_export'};

    for(qw/CSV ods List/) {
	if($projet{'options'}->{'format_export'} eq $_) {
	    $w{'options_'.$_}->show;
	} else {
	    $w{'options_'.$_}->hide;
	}
    }
}

sub exporte {
    my $format=$projet{'options'}->{'format_export'};
    my @options=();
    my $ext=$extension_fichier{$format};
    if(!$ext) {
	$ext=lc($format);
    }
    my $code=$projet{'options'}->{'code_examen'};
    $code=$projet{'nom'} if(!$code);
    my $output=absolu('%PROJET/exports/'.$code.'.'.$ext);
    my @needs_module=();

    if($format eq 'CSV') {
	push @options,
	"--option-out","encodage=".bon_encodage('csv'),
	"--option-out","decimal=".$o{'delimiteur_decimal'},
	"--option-out","separateur=".$projet{'options'}->{'export_csv_separateur'},
	"--option-out","cochees=".$projet{'options'}->{'export_csv_cochees'};
    }
    if($format eq 'ods') {
	push @options,
	"--option-out","nom=".$projet{'options'}->{'nom_examen'},
	"--option-out","code=".$projet{'options'}->{'code_examen'};
	push @needs_module,'OpenOffice::OODoc';
    }
    if($format eq 'List') {
	push @options,
	"--option-out","nom=".$projet{'options'}->{'nom_examen'},
	"--option-out","code=".$projet{'options'}->{'code_examen'},
	"--option-out","decimal=".$o{'delimiteur_decimal'},
	"--option-out","pagesize=".$projet{'options'}->{'export_pagesize'},
	"--option-out","ncols=".$projet{'options'}->{'export_ncols'};
    }

    if(@needs_module) {
	# teste si les modules necessaires sont disponibles

	my @manque=();

	for my $m (@needs_module) {
	    if(!check_install(module=>$m)) {
		push @manque,$m;
	    }
	}
	
	if(@manque) {
	    debug 'Exporting to '.$format.': Needs perl modules '.join(', ',@manque);

	    my $dialog = Gtk2::MessageDialog
		->new($w{'main_window'},
		      'destroy-with-parent',
		      'error','ok',
		      __("Exporting to '%s' needs some perl modules that are not installed: %s. Please install these modules or switch to another export format."),
		      $formats_noms{$format},join(', ',@manque)
		      );
	    $dialog->run;
	    $dialog->destroy;      
	    
	    return();
	}
    }
    
    commande('commande'=>["auto-multiple-choice","export",
			  pack_args(
			      "--debug",debug_file(),
			      "--module",$format,
			      "--useall",$projet{'options'}->{'export_include_abs'},
			      "--sort",$projet{'options'}->{'export_sort'},
			      "--fich-notes",absolu($projet{'options'}->{'notes'}),
			      "--fich-assoc",absolu($projet{'options'}->{'association'}),
			      "--fich-noms",absolu($projet{'options'}->{'listeetudiants'}),
			      "--noms-encodage",bon_encodage('liste'),
			      ($projet{'options'}->{'annote_rtl'} ? "--rtl" : "--no-rtl"),
			      "--output",$output,
			      @options
			  ),
			  ],
	     'texte'=>__"Exporting marks...",
	     'progres.id'=>'export',
	     'progres.pulse'=>0.01,
	     'fin'=>sub {
		 if(-f $output) {
		     if($projet{'options'}->{'after_export'} eq 'file') {
			 commande_parallele($o{$ext.'_viewer'},$output);
		     } elsif($projet{'options'}->{'after_export'} eq 'dir') {
			 view_dir(absolu('%PROJET/exports/'));
		     }
		 } else {
		     my $dialog = Gtk2::MessageDialog
			 ->new($w{'main_window'},
			       'destroy-with-parent',
			       'warning','ok',
			       __"Export to %s did not work: file not created...",$output);
		     $dialog->run;
		     $dialog->destroy;
		 }
	     }
	     );
}

## tri pour IDS

$diag_store->set_sort_func(DIAG_ID,\&sort_id,DIAG_ID);

## menu contextuel sur liste diagnostique -> visualisation zoom/page

my %diag_menu=(page=>{text=>__"page adjustment",icon=>'gtk-zoom-fit'},
	       zoom=>{text=>__"boxes zooms",icon=>'gtk-zoom-in'},
	       );

sub zooms_display {
    my ($id,$forget_it)=@_;
		    
    debug "Zooms view for $id...";
    my $zd=absolu('%PROJET/cr/zooms')."/".id2idf($id,'simple'=>1);
    debug "Zooms directory $zd";
    if($w{'zooms_window'} &&
       $w{'zooms_window'}->actif) {
	$w{'zooms_window'}->page($id,$zd,$forget_it);
    } elsif(!$forget_it) {
	$w{'zooms_window'}=AMC::Gui::Zooms::new('seuil'=>$projet{'options'}->{'seuil'},
						'n_cols'=>$o{'assoc_ncols'},
						'zooms_dir'=>$zd,
						'page_id'=>$id,
						'size-prefs',\%o,
						'encodage_interne'=>$o{'encodage_interne'},
						'an-data'=>$projet{'_an_list'},
						'cr-dir'=>absolu($projet{'options'}->{'cr'}),
	    );
    }
}

sub zooms_line {
    my $iter=$w{'diag_tree'}->get_selection->get_selected;
    my $id=$diag_store->get($iter,DIAG_ID);
    zooms_display($id,1);
}

$w{'diag_tree'}->signal_connect('button_release_event' =>
    sub {
	my ($self, $event) = @_;
	return 0 unless $event->button == 3;
	my ($path, $column, $cell_x, $cell_y) = 
	    $w{'diag_tree'}->get_path_at_pos ($event->x, $event->y);
	if ($path) {
	    
	    my $id=$diag_store->get($diag_store->get_iter($path),
				    DIAG_ID);

	    my $menu = Gtk2::Menu->new;
	    my $c=0;
	    my @actions=('page');

	    # new zooms viewer

	    my $zd=absolu('%PROJET/cr/zooms')."/".id2idf($id,'simple'=>1);

	    if(-d $zd) {
		$c++;
		my $item = Gtk2::ImageMenuItem->new($diag_menu{'zoom'}->{text});
		$item->set_image(Gtk2::Image->new_from_icon_name($diag_menu{'zoom'}->{icon},'menu'));
		$menu->append ($item);
		$item->show;
		$item->signal_connect (activate => sub {
		    my (undef, $sortkey) = @_;
		    zooms_display($id);
				       }, $_);
	    } else {
		push  @actions,'zoom';
	    }

	    # page viewer and old zooms viewer

	    foreach (@actions) {
		my $f=id2file($id,$_,'jpg');
		if(-f $f) {
		    $c++;
		    my $item = Gtk2::ImageMenuItem->new($diag_menu{$_}->{text});
		    $item->set_image(Gtk2::Image->new_from_icon_name($diag_menu{$_}->{icon},'menu'));
		    $menu->append ($item);
		    $item->show;
		    $item->signal_connect (activate => sub {
			my (undef, $sortkey) = @_;
			debug "Looking at $f...";
			commande_parallele($o{'img_viewer'},$f);
		    }, $_);
		}
	    }
	    $menu->popup (undef, undef, undef, undef,
			  $event->button, $event->time) if($c>0);
	    return 1; # stop propagation!
	    
	}
    });

### modele inconnus

my $inconnu_store = Gtk2::ListStore->new ('Glib::String','Glib::String');

$w{'inconnu_tree'}->set_model($inconnu_store);

$renderer=Gtk2::CellRendererText->new;
$column = Gtk2::TreeViewColumn->new_with_attributes ("scan",
						     $renderer,
						     text=> INCONNU_SCAN);
$w{'inconnu_tree'}->append_column ($column);

$renderer=Gtk2::CellRendererText->new;
$column = Gtk2::TreeViewColumn->new_with_attributes ("ID",
						     $renderer,
						     text=> INCONNU_ID);
$w{'inconnu_tree'}->append_column ($column);


### Appel a des commandes externes -- log, annulation

my %les_commandes=();
my $cmd_id=0;

sub commande {
    my (@opts)=@_;
    $cmd_id++;

    my $c=AMC::Gui::Commande::new('avancement'=>$w{'avancement'},
				  'log'=>$w{'log_general'},
				  'finw'=>sub {
				      my $c=shift;
				      $w{'onglets_projet'}->set_sensitive(1);
				      $w{'commande'}->hide();
				      delete $les_commandes{$c->{'_cmdid'}};
				  },
				  @opts);

    $c->{'_cmdid'}=$cmd_id;
    $les_commandes{$cmd_id}=$c;

    $w{'onglets_projet'}->set_sensitive(0);
    $w{'commande'}->show();

    $c->open();
}
    
sub commande_annule {
    for (keys %les_commandes) { $les_commandes{$_}->quitte(); }
}

sub commande_parallele {
    my (@c)=(@_);
    if(commande_accessible($c[0])) {
	my $pid=fork();
	if($pid==0) {
	    debug "Command // [$$] : ".join(" ",@c);
	    exec(@c) ||
		debug "Exec $$ : error";
	    exit(0);
	}
    } else {
	my $dialog = Gtk2::MessageDialog
	    ->new_with_markup($w{'main_window'},
			      'destroy-with-parent',
			      'error','ok',
			      sprintf(__"Following command could not be run: <b>%s</b>, perhaps due to a poor configuration?",$c[0]));
	$dialog->run;
	$dialog->destroy;
	
    }
}

### Actions des menus

my $proj_store;

sub projet_nouveau {
    liste_des_projets('cree'=>1);
}

sub projet_charge {
    liste_des_projets();
}

sub projet_gestion {
    liste_des_projets('gestion'=>1);
}

sub liste_des_projets {
    my %oo=(@_);
    my @projs;
    
    mkdir($o{'rep_projets'}) if(-d $o{'rep_projets'});
    
    # construit la liste des projets existants

    if(-d $o{'rep_projets'}) {
	opendir(DIR, $o{'rep_projets'}) 
	    || die "Error opening directory ".$o{'rep_projets'}." : $!";
	my @f=map { decode("utf-8",$_); } readdir(DIR);
	debug "F:".join(',',map { $_.":".(-d $o{'rep_projets'}."/".$_) } @f);

	@projs = grep { ! /^\./ && -d $o{'rep_projets'}."/".$_ } @f;
	closedir DIR;
	debug "[".$o{'rep_projets'}."] P:".join(',',@projs);
    }

    if($#projs>=0 || $oo{'cree'}) {

	# fenetre pour demander le nom du projet
	
	my $gp=Gtk2::GladeXML->new($glade_xml,'choix_projet','auto-multiple-choice');
	$gp->signal_autoconnect_from_package('main');

	for(qw/choix_projet label_etat label_action choix_projets_liste
	    projet_bouton_ouverture projet_bouton_creation
	    projet_bouton_supprime projet_bouton_annule 
	    projet_bouton_annule_label projet_bouton_renomme
	    projet_bouton_mv_yes projet_bouton_mv_no
	    projet_nom projet_nouveau_syntaxe projet_nouveau/) {
	    $w{$_}=$gp->get_widget($_);
	}

	if($oo{'cree'}) {
	    $w{'projet_nouveau'}->show();
	    $w{'projet_bouton_creation'}->show();
	    $w{'projet_bouton_ouverture'}->hide();

	    $w{'label_etat'}->set_text(__"Existing projects:");

	    $w{'choix_projet'}->set_focus($w{'projet_nom'});
	    $w{'projet_nom_style'} = $w{'projet_nom'}->get_modifier_style->copy;
	}

	
	if($oo{'gestion'}) {
	    $w{'label_etat'}->set_text(__"Projects management:");
	    $w{'label_action'}->set_markup(__"Change project name:");
	    $w{'projet_bouton_ouverture'}->hide();
	    for (qw/supprime renomme/) {
		$w{'projet_bouton_'.$_}->show();
	    }
	    $w{'projet_bouton_annule_label'}->set_text(__"Back");
	}

	# mise a jour liste des projets dans la fenetre
	
	$proj_store = Gtk2::ListStore->new ('Glib::String',
					    'Gtk2::Gdk::Pixbuf');
	
	$w{'choix_projets_liste'}->set_model($proj_store);
	
	$w{'choix_projets_liste'}->set_text_column(PROJ_NOM);
	$w{'choix_projets_liste'}->set_pixbuf_column(PROJ_ICO);
	
	my ($taille,undef)=Gtk2::IconSize->lookup('menu');
        my $pb = Gtk2::IconTheme->get_default->load_icon("auto-multiple-choice",$taille ,"force-svg");
	my $pb_rep = Gtk2::IconTheme->get_default->load_icon("gtk-no",$taille ,"force-svg");
	$pb=$w{'main_window'}->render_icon ('gtk-open', 'menu') if(!$pb);

	for (sort { $a cmp $b } @projs) {
	    $proj_store->set($proj_store->append,
			     PROJ_NOM,$_,
			     PROJ_ICO,
			     (-f fich_options($_) ?
			       $pb : $pb_rep )); 
	}

	# attendons l'action de l'utilisateur (fonctions projet_charge_*)...

	$w{'choix_projet'}->set_keep_above(1);

    } else {
	my $dialog = Gtk2::MessageDialog
	    ->new($w{'main_window'},
		  'destroy-with-parent',
		  'info','ok',
		  __"You don't have any MC project in directory %s!",$o{'rep_projets'});
	$dialog->run;
	$dialog->destroy;
	
    }
}

sub projet_gestion_check {
    # lequel ?
    
    my $sel=$w{'choix_projets_liste'}->get_selected_items();
    my $iter;
    my $proj;

    if($sel) {
	$iter=$proj_store->get_iter($sel);
	$proj=$proj_store->get($iter,PROJ_NOM) if($iter);
    }

    return('','') if(!$proj);

    # est-ce le projet en cours ?

    if($projet{'nom'} && $proj eq $projet{'nom'}) {
	$w{'choix_projet'}->set_keep_above(0);
	my $dialog = Gtk2::MessageDialog
	    ->new($w{'main_window'},
		  'destroy-with-parent',
		  'error','ok',
		  __"You can't change project %s since it's open.",$proj);
	$dialog->run;
	$dialog->destroy;
	$w{'choix_projet'}->set_keep_above(1);
	$proj='';
    }

    return($proj,$iter);
}

my $nom_original='';
my $nom_original_iter='';

sub projet_liste_renomme {
    my ($proj,$iter)=projet_gestion_check();
    return if(!$proj);

    # ouverture zone :
    $w{'projet_nouveau'}->show();
    $w{'projet_nom'}->set_text($proj);

    $nom_original=$proj;
    $nom_original_iter=$iter;

    # boutons...
    for (qw/annule renomme supprime/) {
	$w{'projet_bouton_'.$_}->hide();
    }
    for (qw/mv_no mv_yes/) {
	$w{'projet_bouton_'.$_}->show();
    }
}

sub projet_renomme_fin {
    # fermeture zone :
    $w{'projet_nouveau'}->hide();

    # boutons...
    for (qw/annule renomme supprime/) {
	$w{'projet_bouton_'.$_}->show();
    }
    for (qw/mv_no mv_yes/) {
	$w{'projet_bouton_'.$_}->hide();
    }
}

sub projet_mv_yes {
    projet_renomme_fin();
    
    my $nom_nouveau=$w{'projet_nom'}->get_text();

    return if($nom_nouveau eq $nom_original || !$nom_nouveau);

    if($o{'rep_projets'}) {
	my $dir_original=$o{'rep_projets'}."/".$nom_original;
	if(-d $dir_original) {
	    my $dir_nouveau=$o{'rep_projets'}."/".$nom_nouveau;
	    if(-d $dir_nouveau) {
		$w{'choix_projet'}->set_keep_above(0);
		my $dialog = Gtk2::MessageDialog
		    ->new_with_markup($w{'main_window'},
				      'destroy-with-parent',
				      'error','ok',
				      sprintf(__("Directory <i>%s</i> already exists, so you can't choose this name."),$dir_nouveau));
		$dialog->run;
		$dialog->destroy;      
		$w{'choix_projet'}->set_keep_above(1);

		return;
	    } else {
		# OK

		move($dir_original,$dir_nouveau);

		$proj_store->set($nom_original_iter,
				 PROJ_NOM,$nom_nouveau,
				 );
	    }
	} else {
	    debug "No original directory";
	}
    } else {
	debug "No projects directory";
    }
}

sub projet_mv_no {
    projet_renomme_fin();
}

sub projet_liste_supprime {
    my ($proj,$iter)=projet_gestion_check();
    return if(!$proj);

    # on demande confirmation...
    $w{'choix_projet'}->set_keep_above(0);
    my $dialog = Gtk2::MessageDialog
	->new_with_markup($w{'main_window'},
			  'destroy-with-parent',
			  'warning','ok-cancel',
			  sprintf(__("You asked to remove project <b>%s</b>.")." "
				  .__("This will permanently erase all the files of this project, including the LaTeX source as well as all the files you put in the directory of this project, as the scans for example.")." "
				  .__("Is this really what you want?"),$proj));
    my $reponse=$dialog->run;
    $dialog->destroy;      
    $w{'choix_projet'}->set_keep_above(1);
    
    if($reponse ne 'ok') {
	return;
    } 
    
    debug "Removing project $proj !";
    
    $proj_store->remove($iter);
    
    # suppression effective des fichiers...
    
    if($o{'rep_projets'}) {
	my $dir=$o{'rep_projets'}."/".$proj;
	if(-d $dir) {
	    remove_tree($dir,{'verbose'=>0,'safe'=>1,'keep_root'=>0});
	} else {
	    debug "No directory $dir";
	}
    } else {
	debug "No projects directory";
    }
}

sub projet_charge_ok {

    # ouverture projet deja existant

    my $sel=$w{'choix_projets_liste'}->get_selected_items();
    my $proj;

    if($sel) {
	$proj=$proj_store->get($proj_store->get_iter($sel),PROJ_NOM);
    }

    $w{'choix_projet'}->destroy();

    if($proj) {
	my $reponse='yes';
	if(! -f fich_options($proj)) {
	    my $dialog = Gtk2::MessageDialog
		->new_with_markup($w{'main_window'},
				  'destroy-with-parent',
				  'warning','yes-no',
				  sprintf(__("You selected directory <b>%s</b> as a project to open.")." "
					  .__("However, this directory does not seem to contain a project. Dou you still want to try?"),$proj));
	    $reponse=$dialog->run;
	    $dialog->destroy;      
	}
	projet_ouvre($proj) if($reponse eq 'yes');
    }
}

sub restricted_check {
    my ($text,$style,$warning,$chars)=@_;
    my $nom=$text->get_text();
    if($nom =~ s/[^$chars]//g) {
	$text->set_text($nom);
	$warning->show();

	for(qw/normal active/) {
	    $text->modify_base($_,Gtk2::Gdk::Color->parse('#FFC0C0'));
	}
	Glib::Timeout->add (500, sub {
	    $text->modify_style($style);
	    return 0;
	});
    }
}

sub projet_nom_verif {
    restricted_check($w{'projet_nom'},$w{'projet_nom_style'},$w{'projet_nouveau_syntaxe'},"a-zA-Z0-9._+:-");
}

sub projet_charge_nouveau {

    # creation nouveau projet

    my $proj=$w{'projet_nom'}->get_text();
    $w{'choix_projet'}->destroy();

    # existe deja ?

    if(-e $o{'rep_projets'}."/$proj") {

	my $dialog = Gtk2::MessageDialog
	    ->new_with_markup($w{'main_window'},
			      'destroy-with-parent',
			      'error','ok',
			      sprintf(__("The name <b>%s</b> is already used in the projects directory.")." "
				      .__"You must choose another name to create a project.",$proj));
	$dialog->run;
	$dialog->destroy;      
	

    } else {

	if(projet_ouvre($proj,1)) {
	    projet_sauve();
	}

    }
}

sub projet_charge_non {
    $w{'choix_projet'}->destroy();
}

sub projet_sauve {
    debug "Saving project...";
    my $of=fich_options($projet{'nom'});
    my $po={%{$projet{'options'}}};

    for(qw/listeetudiants/) {
	$po->{$_}=relatif($po->{$_});
    }
    
    if(pref_xx_ecrit($po,'projetAMC',$of)) {
	my $dialog = Gtk2::MessageDialog
	    ->new($w{'main_window'},
		  'destroy-with-parent',
		  'error','ok',
		  __"Error writing to options file %s : %s",$of,$!);
	$dialog->run;
	$dialog->destroy;      
    } else {
	$projet{'options'}->{'_modifie'}=0;
	$projet{'options'}->{'_modifie_ok'}=0;
    }
}

sub projet_check_and_save {
    if($projet{'nom'}) {
	valide_options_notation();
	if($projet{'options'}->{'_modifie_ok'} 
	   || $projet{'options'}->{'_modifie'}) {
	    projet_sauve();
	}
    }
}

### Actions des boutons de la partie DOCUMENTS

sub doc_active {
    my $sel=$w{'documents_tree'}->get_selection()->get_selected_rows()->get_indices();
    #print "Active $sel...\n";
    my $f=absolu($projet{'options'}->{'docs'}->[$sel]);
    debug "Looking at $f...";
    commande_parallele(($f =~ /\.xy$/ ? $o{'txt_editor'} : $o{'pdf_viewer'}),$f);
}

sub mep_active {
    my $sel=$w{'mep_tree'}->get_selection()->get_selected_rows()->get_indices();
    my $id=($projet{'_mep_list'}->ids())[$sel];
    debug "Active MEP $sel : ID=$id...";
    my $f=$projet{'_mep_list'}->filename($id);
    debug "Looking at $f...";
    commande_parallele($o{'xml_viewer'},$f);
}

sub fichiers_mep {
    my $md=absolu($projet{'options'}->{'mep'});
    opendir(MDIR, $md) || die "can't opendir $md: $!";
    my @meps = map { "$md/$_" } grep { /^mep.*xml$/ && -f "$md/$_" } readdir(MDIR);
    closedir MDIR;
    return(@meps);
}

sub mini {($_[0]<$_[1] ? $_[0] : $_[1])}

sub doc_maj {
    my $sur=0;
    if($projet{'_an_list'}->nombre()>0) {
	my $dialog = Gtk2::MessageDialog
	    ->new_with_markup($w{'main_window'},
			      'destroy-with-parent',
			      'warning','ok-cancel',
			      __("Papers analysis was already made on the basis of the current working documents.")." "
			      .__("You already made the examination on the basis of these documents.")." "
			      .__("If you modify working documents, you will not be capable any more of analyzing the papers you have already distributed!")." "
			      .__("Do you wish to continue?")." "
			      .__("Click on Validate to erase the former layouts and update working documents, or on Cancel to cancel this operation.")." "
			      ."<b>".__("To allow the use of an already printed question, cancel!")."</b>");
	my $reponse=$dialog->run;
	$dialog->destroy;      
	
	if($reponse eq 'cancel') {
	    return(0);
	} 

	$sur=1;
    }
	
    # deja des MEP fabriquees ?
    my @meps=fichiers_mep();
    if(@meps) {
	if(!$sur) {
	    my $dialog = Gtk2::MessageDialog
		->new_with_markup($w{'main_window'},
				  'destroy-with-parent',
				  'question','ok-cancel',
				  __("Layouts are already calculated for the current documents.")." "
				  .__("Updating working documents, the layouts will become obsolete and will thus be erased.")." "
				  .__("Do you wish to continue?")." "
				  .__("Click on Validate to erase the former layouts and update working documents, or on Cancel to cancel this operation.")
				  ." <b>".__("To allow the use of an already printed question, cancel!")."</b>");
	    my $reponse=$dialog->run;
	    $dialog->destroy;      
	    
	    if($reponse eq 'cancel') {
		return(0);
	    } 
	}
	
	unlink @meps;
	detecte_mep();
    }   

    # new layout document : XY (from LaTeX)
    
    if($projet{'options'}->{'docs'}->[2] =~ /\.pdf$/) {
	$projet{'options'}->{'docs'}->[2]=$projet_defaut{'docs'}->[2];
	$projet{'options'}->{'_modifie'}=1;
    }

    #
    commande('commande'=>["auto-multiple-choice","prepare",
			  "--with",moteur_latex(),
			  "--debug",debug_file(),
			  "--out-sujet",absolu($projet{'options'}->{'docs'}->[0]),
			  "--out-corrige",absolu($projet{'options'}->{'docs'}->[1]),
			  "--out-calage",absolu($projet{'options'}->{'docs'}->[2]),
			  "--mode","s",
			  "--n-copies",$projet{'options'}->{'nombre_copies'},
			  absolu($projet{'options'}->{'texsrc'}),
			  "--prefix",absolu('%PROJET/'),
			  ],
	     'signal'=>2,
	     'texte'=>__"Documents update...",
	     'progres.id'=>'MAJ',
	     'progres.pulse'=>0.01,
	     'fin'=>sub { 
		 my $c=shift;
		 my @err=$c->erreurs();
		 if(@err) {
		     my $dialog = Gtk2::MessageDialog
			 ->new_with_markup($w{'main_window'},
					   'destroy-with-parent',
					   'error','ok',
					   __("Errors while compiling LaTeX source.")." "
					   .__("You have to correct LaTeX source and re-run documents update.")." "
					   .sprintf(__("See the LaTeX log in '%s' below."),__"Command output details")." "
					   .__("Use LaTeX editor or latex command for a precise diagnosis.")."\n\n".join("\n",@err[0..mini(9,$#err)]).($#err>9 ? "\n\n<i>(".__("Only first ten errors written").")</i>": "") );
		     $dialog->run;
		     $dialog->destroy;
		 } else {
		     # verif que tout y est

		     my $ok=1;
		     for(0..2) {
			 $ok=0 if(! -f absolu($projet{'options'}->{'docs'}->[$_]));
		     }
		     dialogue_apprentissage('MAJ_DOCS_OK','','',
					    __("Working documents successfully generated.")." "
					    .__("You can take a look at them double-clicking on the list.")." "
					    .__("If they are correct, proceed to layouts detection...")) if($ok);
		 }

		 my $ap=($c->variable('ensemble') ? 'case' : 'marge');
		 $projet{'options'}->{'_modifie'}=1 
		     if($projet{'options'}->{'annote_position'} ne $ap);
		 $projet{'options'}->{'annote_position'}=$ap;

		 my $ensemble=$c->variable('ensemble') && !$c->variable('outsidebox');
		 if(($ensemble  || $c->variable('insidebox'))
		    && $projet{'options'}->{'seuil'}<0.4) {
		     my $dialog = Gtk2::MessageDialog
			 ->new_with_markup($w{'main_window'},
					   'destroy-with-parent',
					   'question','yes-no',
					   sprintf(($ensemble ?
						    __("Your question has a separate answers page.")." "
						    .__("In this case, letters are shown inside boxes.") :
						   __("Your question is set to present labels inside the boxes to be ticked."))
						   ." "
						   .__("For better ticking detection, ask students to fill out completely boxes, and choose parameter \"%s\" around 0.5 for this project.")." "
						   .__("At the moment, this parameter is set to %.02f.")." "
						   .__("Would you like to set it to 0.5?")
						   ,__"darkness threshold",$projet{'options'}->{'seuil'}) );
		     my $reponse=$dialog->run;
		     $dialog->destroy;
		     if($reponse) {
			 $projet{'options'}->{'seuil'}=0.5;
			 $projet{'options'}->{'_modifie'}=1;
		     }
		 }
		 detecte_documents(); 
	     });
    
}

my $cups;
my $g_imprime;

sub nonnul {
    my $s=shift;
    $s =~ s/\000//g;
    return($s);
}

sub autre_imprimante {
    my $i=$w{'imprimante'}->get_model->get($w{'imprimante'}->get_active_iter,COMBO_ID);
    debug "Choix imprimante $i";
    my $ppd=$cups->getPPD($i);

    my %alias=();
    my %trouve=();

    debug "Looking for staple opton...";

  CHOIX: for my $i (qw/StapleLocation/) {
      my $oi=$ppd->getOption($i);
      
      $alias{$i}='agrafe';
      
      if(%$oi) {
	  my $k=nonnul($oi->{'keyword'});
	  debug "$i -> KEYWORD $k";
	  my $ok=$o{'options_impression'}->{$k};
	  my @possibilites=(map { (nonnul($_->{'choice'}),
				   nonnul($_->{'text'})) }
			    (@{$oi->{'choices'}}));
	  my %ph=(@possibilites);
	  $cb_stores{'agrafe'}=cb_model(@possibilites);
	  $o{'options_impression'}->{$k}=nonnul($oi->{'defchoice'})
	      if(!$ok || !$ph{$ok});

	  $alias{$k}='agrafe';
	  $trouve{'agrafe'}=$k;

	  last CHOIX;
      }
  }
    if(!$trouve{'agrafe'}) {
	debug "No possible staple";

	$cb_stores{'agrafe'}=cb_model(''=>__"(not supported)");
	$w{'imp_c_agrafe'}->set_model($cb_stores{'agrafe'});
    }

    transmet_pref($g_imprime,'imp',$o{'options_impression'},
		  \%alias);
}

sub sujet_impressions {

    if(! -f absolu($projet{'options'}->{'docs'}->[0])) {
	my $dialog = Gtk2::MessageDialog
	    ->new_with_markup($w{'main_window'},
			      'destroy-with-parent',
			      'error','ok',
			      __"You don't have any question to print: please check your LaTeX source and update working documents first.");
	$dialog->run;
	$dialog->destroy;
	
	return();
    }

    if($projet{'_mep_list'}->nombre==0) {
	my $dialog = Gtk2::MessageDialog
	    ->new_with_markup($w{'main_window'},
			      'destroy-with-parent',
			      'error','ok',
			      __("Question's pages are not detected.")." "
			      .__"Perhaps you forgot to compute layouts?");
	$dialog->run;
	$dialog->destroy;
	
	return();
    }

    debug "Choosing pages to print...";

    if($o{'methode_impression'} eq 'CUPS') {
	# teste si le paquet Net::CUPS est disponible

	my @manque=();

	for my $m ("Net::CUPS","Net::CUPS::PPD") {
	    if(check_install(module=>$m)) {
		load($m);
	    } else {
		push @manque,$m;
	    }
	}
	
	if(@manque) {
	    debug 'Printing with CUPS: Needs perl modules '.join(', ',@manque);

	    my $dialog = Gtk2::MessageDialog
		->new($w{'main_window'},
		      'destroy-with-parent',
		      'error','ok',
		      __("Printing with method '%s' needs some perl modules that are not installed: %s. Please install these modules or switch to another printing method."),
		      __"CUPS",join(', ',@manque)
		      );
	    $dialog->run;
	    $dialog->destroy;      
	    
	    return();
	}

	# verifie aussi qu'il y a au moins une imprimante configuree

	my $sc=Net::CUPS->new();
	my @pl = $sc->getDestinations();

	if(!@pl) {
	    my $dialog = Gtk2::MessageDialog
		->new($w{'main_window'},
		      'destroy-with-parent',
		      'error','ok',
		      __("You chose printing method '%s' but there are no configured printer in CUPS. Please configure some printer or switch to another printing method."),
		      __"CUPS"
		      );
	    $dialog->run;
	    $dialog->destroy;      
	    
	    return();
	}
    }

    $g_imprime=Gtk2::GladeXML->new($glade_xml,'choix_pages_impression','auto-multiple-choice');
    $g_imprime->signal_autoconnect_from_package('main');
    for(qw/choix_pages_impression arbre_choix_copies bloc_imprimante imprimante imp_c_agrafe bloc_fichier/) {
	$w{$_}=$g_imprime->get_widget($_);
    }

    if($o{'methode_impression'} eq 'CUPS') {
	$w{'bloc_imprimante'}->show();

	$cups=Net::CUPS->new();

	# les imprimantes :

	my @printers = $cups->getDestinations();
	debug "Printers : ".join(' ',map { $_->getName() } @printers);
	my $p_model=cb_model(map { ($_->getName(),$_->getDescription() || $_->getName()) } @printers);
	$w{'imprimante'}->set_model($p_model);
	if(! $o{'imprimante'}) {
	    my $defaut=$cups->getDestination();
	    if($defaut) {
		$o{'imprimante'}=$defaut->getName();
	    } else {
		$o{'imprimante'}=$printers[0]->getName();
	    }
	}
	my $i=model_id_to_iter($p_model,COMBO_ID,$o{'imprimante'});
	if($i) {
	    $w{'imprimante'}->set_active_iter($i);
	}

	# transmission

	transmet_pref($g_imprime,'imp',$o{'options_impression'});
    }

    if($o{'methode_impression'} eq 'file') {
	$w{'bloc_imprimante'}->hide();
	$w{'bloc_fichier'}->show();

	transmet_pref($g_imprime,'impf',$o{'options_impression'});
    }

    $copies_store->clear();
    for my $c ($projet{'_mep_list'}->etus()) {
	$copies_store->set($copies_store->append(),COPIE_N,$c);
    }

    $w{'arbre_choix_copies'}->set_model($copies_store);

    my $renderer=Gtk2::CellRendererText->new;
    my $column = Gtk2::TreeViewColumn->new_with_attributes (__"papers",
							    $renderer,
							    text=> COPIE_N );
    $w{'arbre_choix_copies'}->append_column ($column);

    $w{'arbre_choix_copies'}->get_selection->set_mode("multiple");

}

sub sujet_impressions_cancel {
    
    if(get_debug()) {
	reprend_pref('imp',$o{'options_impression'});
	debug(Dumper($o{'options_impression'}));
    }

    $w{'choix_pages_impression'}->destroy;
}

sub sujet_impressions_ok {
    my $os='none';
    my @e=();

    for my $i ($w{'arbre_choix_copies'}->get_selection()->get_selected_rows() ) {
	push @e,$copies_store->get($copies_store->get_iter($i),COPIE_N);
    }

    if($o{'methode_impression'} eq 'CUPS') {
	my $i=$w{'imprimante'}->get_model->get($w{'imprimante'}->get_active_iter,COMBO_ID);
	if($i ne $o{'imprimante'}) {
	    $o{'imprimante'}=$i;
	    $o{'_modifie'}=1;
	}

	reprend_pref('imp',$o{'options_impression'});

	if($o{'options_impression'}->{'_modifie'}) {
	    $o{'_modifie'}=1;
	    delete $o{'options_impression'}->{'_modifie'};
	}

	$os=join(',',map { $_."=".$o{'options_impression'}->{$_} } 
		 grep { $o{'options_impression'}->{$_} }
		 (keys %{$o{'options_impression'}}) );

	debug("Printing options : $os");
    }

    if($o{'methode_impression'} eq 'file') {
	reprend_pref('impf',$o{'options_impression'});
	
	if($o{'options_impression'}->{'_modifie'}) {
	    $o{'_modifie'}=1;
	    delete $o{'options_impression'}->{'_modifie'};
	}

	if(!$o{'options_impression'}->{'repertoire'}) {
	    debug "Print to file : no destionation...";
	    $o{'options_impression'}->{'repertoire'}='';
	} else {
	    mkdir($o{'options_impression'}->{'repertoire'})
		if(! -e $o{'options_impression'}->{'repertoire'});
	}
    }

    $w{'choix_pages_impression'}->destroy;
    
    debug "Printing: ".join(",",@e);

    if(!@e) {
	# No page selected: 
	my $dialog = Gtk2::MessageDialog
	    ->new($w{'main_window'},
		  'destroy-with-parent',
		  'info','ok',
		  __("You did not select any sheet to print..."));
	$dialog->run;
	$dialog->destroy;
	return();
    }

    if(1+$#e < 10) {
	# Less than 10 pages selected: is it a mistake?
	my $resp=dialogue_apprentissage('PRINT_FEW_PAGES',
					'warning','yes-no',
					__("You selected only a few sheets to print.")."\n".
					__("You must create as many exam sheets as necessary for all your students, with different sheets numbers, and print them all.")." ".
					__("If you print one or several sheets and photocopy them to have enough for all the students, <b>you won't be able to
continue with AMC!</b>")."\n".
					__("Do you want to print the selected sheets anyway?")
	    );
	return() if($resp eq 'no');
    }

    my $fh=File::Temp->new(TEMPLATE => "nums-XXXXXX",
			   TMPDIR => 1,
			   UNLINK=> 1);
    print $fh join("\n",@e)."\n";
    $fh->seek( 0, SEEK_END );

    commande('commande'=>["auto-multiple-choice","imprime",
			  "--methode",$o{'methode_impression'},
			  "--imprimante",$o{'imprimante'},
			  "--options",$os,
			  "--output",$o{'options_impression'}->{'repertoire'}."/copie-%e.pdf",
			  "--print-command",$o{'print_command_pdf'},
			  "--sujet",absolu($projet{'options'}->{'docs'}->[0]),
			  "--mep",absolu($projet{'options'}->{'mep'}),
			  "--progression-id",'impression',
			  "--progression",1,
			  "--debug",debug_file(),
			  "--fich-numeros",$fh->filename,
			  ],
	     'signal'=>2,
	     'texte'=>__"Print papers one by one...",
	     'progres.id'=>'impression',
	     'o'=>{'fh'=>$fh,'etu'=>\@e,'printer'=>$o{'imprimante'},'method'=>$o{'methode_impression'}},
	     'fin'=>sub {
		 my $c=shift;
		 close($c->{'o'}->{'fh'});
		 save_state_after_printing($c->{'o'});
	     },

	     );
}

sub save_state_after_printing {
    my $c=shift;
    my $st=AMC::State::new('directory'=>absolu('%PROJET/'));

    $st->read();

    my @files=(@{$projet{'options'}->{'docs'}},
	       absolu($projet{'options'}->{'texsrc'}));
    
    if(!$st->check_local_md5(@files)) {
	$st=AMC::State::new('directory'=>absolu('%PROJET/'));
	$st->add_local_files(@files);
    }
    
    $st->add_print('printer'=>$c->{'printer'},
		   'method'=>$c->{'method'},
		   'content'=>join(',',@{$c->{'etu'}}));
    $st->write();
    
}

sub calcule_mep {
    # on efface les anciennes MEP
    my @meps=fichiers_mep();
    unlink @meps;
    # on recalcule...
    commande('commande'=>["auto-multiple-choice","prepare",
			  "--with",moteur_latex(),
			  "--debug",debug_file(),
			  "--calage",absolu($projet{'options'}->{'docs'}->[2]),
			  "--progression-id",'MEP',
			  "--progression",1,
			  "--n-procs",$o{'n_procs'},
			  "--mode","m",
			  absolu($projet{'options'}->{'texsrc'}),
			  "--mep",absolu($projet{'options'}->{'mep'}),
			  ],
	     'texte'=>__"Detecting layouts...",
	     'progres.id'=>'MEP',
	     'fin'=>sub { 
		 detecte_mep();
		 if($projet{'_mep_list'}->nombre()<1) {
		     # avertissement...
		     my $dialog = Gtk2::MessageDialog
			 ->new_with_markup($w{'main_window'},
					   'destroy-with-parent',
					   'error', # message type
					   'ok', # which set of buttons?
					   __("No layout detected.")." "
					   .__("<b>Don't go through the examination</b> before fixing this problem, otherwise you won't be able to use AMC for correction."));
		     $dialog->run;
		     $dialog->destroy;
		     
		 } else {
		     dialogue_apprentissage('MAJ_MEP_OK','','',
					    __("Layouts are detected.")." "
					    .sprintf(__"You can check all is correct clicking on button <i>%s</i> and looking at question pages to see if red bozes are weel positioned.",__"Check layouts")." "
					    .__"Then you can proceed to printing and to examination.");
		 }
	     });
}

sub verif_mep {
    saisie_manuelle(0,0,1);
}

### Actions des boutons de la partie SAISIE

sub saisie_manuelle {
    my ($self,$event,$regarder)=@_;
    if($projet{'_mep_list'}->nombre()>0) {
	my $gm=AMC::Gui::Manuel::new('cr-dir'=>absolu($projet{'options'}->{'cr'}),
				     'mep-dir'=>absolu($projet{'options'}->{'mep'}),
				     'mep-data'=>$projet{'_mep_list'},
				     'an-data'=>$projet{'_an_list'},
				     'liste'=>absolu($projet{'options'}->{'listeetudiants'}),
				     'sujet'=>absolu($projet{'options'}->{'docs'}->[0]),
				     'etud'=>'',
				     'dpi'=>$o{'saisie_dpi'},
				     'seuil'=>$projet{'options'}->{'seuil'},
				     'seuil_sens'=>$o{'seuil_sens'},
				     'seuil_eqm'=>$o{'seuil_eqm'},
				     'global'=>0,
				     'encodage_interne'=>$o{'encodage_interne'},
				     'encodage_liste'=>bon_encodage('liste'),
				     'image_type'=>$o{'manuel_image_type'},
				     'retient_m'=>1,
				     'editable'=>($regarder ? 0 : 1),
				     'en_quittant'=>($regarder ? '' : \&detecte_analyse),
				     );
    } else {
	my $dialog = Gtk2::MessageDialog
	    ->new_with_markup($w{'main_window'},
			      'destroy-with-parent',
			      'error','ok',
			      __("No layout for this project.")." "
			      .sprintf(__("Please use button <i>%s</i> in <i>%s</i> before manual data capture."),__"Compute layouts",__"Preparation"));
	$dialog->run;
	$dialog->destroy;      
    }
}

sub saisie_automatique {
    my $gsa=Gtk2::GladeXML->new($glade_xml,'saisie_auto','auto-multiple-choice');
    $gsa->signal_autoconnect_from_package('main');
    for(qw/saisie_auto copie_scans/) {
	$w{$_}=$gsa->get_widget($_);
    }
    $w{'copie_scans'}->set_active(1);
}

sub saisie_auto_annule {
    $w{'saisie_auto'}->destroy();
}

sub analyse_call {
    my (%oo)=@_;
    # make temporary file with the list of images to analyse

    my $fh=File::Temp->new(TEMPLATE => "liste-XXXXXX",
			   TMPDIR => 1,
			   UNLINK=> 1);
    print $fh join("\n",@{$oo{'f'}})."\n";
    $fh->seek( 0, SEEK_END );

    my @args=("--debug",debug_file(),
	      "--seuil-coche",$projet{'options'}->{'seuil'},
	      "--tol-marque",$o{'tolerance_marque_inf'}.','.$o{'tolerance_marque_sup'},
	      "--progression-id",'analyse',
	      "--progression",1,
	      "--n-procs",$o{'n_procs'},
	      "--mep",absolu($projet{'options'}->{'mep'}),
	      "--mep-saved",absolu($mep_saved),
	      "--projet",absolu('%PROJET/'),
	      "--cr",absolu($projet{'options'}->{'cr'}),
	      "--liste-fichiers",$fh->filename,
	);

    # Diagnostic image file ?

    if($oo{'diagnostic'}) {
	push @args,"--debug-image-dir",absolu('%PROJET/cr/diagnostic');
    }

    # call AMC-analyse

    commande('commande'=>["auto-multiple-choice","analyse",
	     @args],
	     'signal'=>2,
	     'texte'=>$oo{'text'},
	     'progres.id'=>$oo{'progres'},
	     'o'=>{'fh'=>$fh},
	     'fin'=>$oo{'fin'},
	     );
}

sub saisie_auto_ok {
    my @f=$w{'saisie_auto'}->get_filenames();
    my $copie=$w{'copie_scans'}->get_active();

    $w{'saisie_auto'}->destroy();
    Gtk2->main_iteration while ( Gtk2->events_pending );

    # split multipage files

    my @fs=();

    my $splitinfo=$w{'avancement'}->get_text();
    $w{'onglets_projet'}->set_sensitive(0);
    $w{'commande'}->show();
    $w{'annulation'}->set_sensitive(0);
    Gtk2->main_iteration while ( Gtk2->events_pending );

    for my $fich (@f) {
	my (undef,undef,$fich_n)=splitpath($fich);
	my $suffix_change='';
	my @pre_options=();

	# number of pages :
	my $np=0;
	# any scene with number > 0 ? This should cause problems with OpenCV
	my $scene=0;
	open(NP,"-|",magick_module("identify"),"-format","%s\n",$fich);
	while(<NP>) {
	    chomp();
	    if(/[^\s]/) {
		$np++;
		$scene=1 if($_ > 0);
	    }
	}
	close(NP);
	# Is this a vector format file? If so, we have to convert it
	# to bitmap
	my $vector='';
	if($fich_n =~ /\.(pdf|eps|ps)$/i) {
	    $vector=1;
	    $suffix_change='.png';
	    @pre_options=('-density',$o{'vector_scan_density'})
		if($o{'vector_scan_density'});
	}

	debug "> Scan $fich: $np page(s)".($scene ? " [has scene>0]" : "");
	if($np>1 || $scene || $vector) {
	    # split multipage image into 1-page images, and/or convert
	    # to bitmap format

	    $w{'commande'}->show();
	    $w{'avancement'}->set_text((__"Splitting multi-page image")." ".
				       $fich_n."...");
	    $w{'avancement'}->set_fraction(0);
	    Gtk2->main_iteration while ( Gtk2->events_pending );
	    
	    my $temp_loc=tmpdir();
	    my $temp_dir = tempdir( DIR=>$temp_loc,
				    CLEANUP => (!get_debug()) );
	    
	    debug "Image split tmp dir: $temp_dir";
	    
	    my ($fxa,$fxb,$fb) = splitpath($fich);
	    if(! ($fb =~ s/\.([^.]+)$/_%04d.$1/)) { 
		$fb .= '_%04d';
	    }
	    $fb.=$suffix_change;

	    system(magick_module("convert"),@pre_options,$fich,"+adjoin","$temp_dir/$fb");
	    opendir(my $dh, $temp_dir) || debug "can't opendir $temp_dir: $!";
	    my @split = grep { -f "$temp_dir/$_" } readdir($dh);
	    closedir $dh;
	    
	    # if not to be copied in project dir, put them in the
	    # same directory as original image
	    
	    if($copie) {
		push @fs,map { "$temp_dir/$_" } @split;
	    } else {
		for(@split) {
		    my $dest=catpath($fxa,$fxb,$_);
		    debug "Moving one page to $dest";
		    move("$temp_dir/$_",$dest);
		    push @fs,$dest;
		}
	    }
	} else {
	    push @fs,$fich;
	}
    }

    @f=@fs;

    # if requested, copy files to project directory

    $w{'avancement'}->set_text(__"Copying scans to project directory...");
    Gtk2->main_iteration while ( Gtk2->events_pending );

    if($copie) {
	my @fl=();
	my $c=0;
	for my $fich (@f) {
	    my ($fxa,$fxb,$fb) = splitpath($fich);
	    my $dest=absolu("scans/".$fb);
	    my $deplace=0;

	    if($fich ne $dest) {
		if(-e $dest) {
		    # dest file already exists: change name
		    debug "File $dest already exists";
		    $dest=new_filename($dest);
		    debug "--> $dest";
		}
		if(copy($fich,$dest)) {
		    push @fl,$dest; 
		    $deplace=1;
		} else {
		    debug "$fich --> $dest";
		    debug "Copy error: $!";
		}
	    }
	    $c+=$deplace;
	    push @fl,$fich if(!$deplace);
	}
	debug "Copying scan files: ".$c."/".(1+$#f);
	@f=@fl;
    }

    clear_old('diagnostic',
	      absolu('%PROJET/cr/diagnostic'));

    $w{'avancement'}->set_text($splitinfo);
    $w{'annulation'}->set_sensitive(1);

    analyse_call('f'=>\@f,
		 'text'=>__("Automatic data capture..."),
		 'progres'=>'analyse',
		 'fin'=>sub {
		     my $c=shift;
		     my @err=$c->erreurs();
		     
		     close($c->{'o'}->{'fh'});
		     
		     my @fe=();
		     for(@err) {
			 if(/ERROR\(([^\)]+)\)\(([^\)]*)\)/) {
			     push @fe,[$1,$2];
			 } else {
			     debug "Unrecognized error : $_";
			 }
		     }
		     detecte_analyse('erreurs'=>\@fe,'apprend'=>1);
		 },
	);
    
}

sub choisit_liste {
    my $dial=Gtk2::GladeXML->new($glade_xml,
			       'liste_dialog','auto-multiple-choice')
	->get_widget('liste_dialog');

    my @f;
    if($projet{'options'}->{'listeetudiants'}) {
	@f=splitpath(absolu($projet{'options'}->{'listeetudiants'}));
    } else {
	@f=splitpath(absolu('%PROJET/'));
    }
    $f[2]='';

    $dial->set_current_folder(catpath(@f));

    my $ret=$dial->run();
    debug("Names list file choice [$ret]");

    my $file=$dial->get_filename();
    $dial->destroy();
    
    if($ret eq '1') {
	# file chosen
	debug("List: ".$file);
	valide_liste('set'=>$file);
    } elsif($ret eq '2') {
	# No list
	valide_liste('set'=>'');
    } else {
	# Cancel
    }
}

sub edite_liste {
    my $f=absolu($projet{'options'}->{'listeetudiants'});
    debug "Editing $f...";
    commande_parallele($o{'txt_editor'},$f);
}

sub valide_liste {
    my %oo=@_;
    debug "* valide_liste";

    if(defined($oo{'set'}) && !$oo{'nomodif'}) {
	$projet{'options'}->{'listeetudiants'}=relatif($oo{'set'});
	$projet{'options'}->{'_modifie'}=1;
    }

    my $fl=absolu($projet{'options'}->{'listeetudiants'});
    $fl='' if(!$projet{'options'}->{'listeetudiants'});

    my $fn=$fl;
    $fn =~ s/.*\///;

    if($fl) {
	$w{'liste_filename'}->set_markup("<b>$fn</b>");
	for(qw/liste_path liste_edit/) {
	    $w{$_}->set_sensitive(1);
	}
    } else {
# TRANSLATORS: Names list file : (none)
	$w{'liste_filename'}->set_markup(__"(none)");
	for(qw/liste_path liste_edit/) {
	    $w{$_}->set_sensitive(0);
	}
    }

    my $l=AMC::NamesFile::new($fl,
			      'encodage'=>bon_encodage('liste'),
			      );
    my ($err,$errlig)=$l->errors();

    if($err) {
	if(!$oo{'noinfo'}) {
	    my $dialog = Gtk2::MessageDialog
		->new_with_markup($w{'main_window'},
				  'destroy-with-parent',
				  'error','ok',
				  sprintf(__"Unsuitable names file: %d errors, first on line %d.",$err,$errlig));
	    $dialog->run;
	    $dialog->destroy;
	}
	$cb_stores{'liste_key'}=$cb_model_vide_key;
    } else {
	# problems with ID (name/surname)
	my $e=$l->problem('ID.empty');
	if($e>0) {
	    debug "NamesFile: $e empty IDs";
	    $w{'liste_refresh'}->show();
	    my $dialog = Gtk2::MessageDialog
		->new_with_markup($w{'main_window'},
				  'destroy-with-parent',
				  'warning','ok',
				  sprintf(__"Found %d empty names in names file <i>%s</i>. Check that <b>name</b> or <b>surname</b> column is present, and always filled.",$e,$fl)." ".__"Edit the names file to correct it, and re-read.");
	    $dialog->run;
	    $dialog->destroy;
	} else {
	    my $d=$l->problem('ID.dup');
	    if(@$d) {
		debug "NamesFile: duplicate IDs [".join(',',@$d)."]";
		if($#{$d}>8) {
		    @$d=(@{$d}[0..8],'(and more)');
		}
		$w{'liste_refresh'}->show();
		my $dialog = Gtk2::MessageDialog
		    ->new_with_markup($w{'main_window'},
				      'destroy-with-parent',
				      'warning','ok',
				      sprintf(__"Found duplicate names: <i>%s</i>. Check that all names are different.",join(', ',@$d))." ".__"Edit the names file to correct it, and re-read.");
		$dialog->run;
		$dialog->destroy;
	    } else {
		# OK, no need to refresh
		$w{'liste_refresh'}->hide();
	    }
	}
	# transmission liste des en-tetes
	my @keys=$l->keys;
	debug "primary keys: ".join(",",@keys);
# TRANSLATORS: you can omit the [...] part, just here to explain context
	$cb_stores{'liste_key'}=cb_model('',__p("(none) [No primary key found in association list]"),
					 map { ($_,$_) } 
					 (@keys));
    }
    transmet_pref($gui,'pref_assoc',$projet{'options'},{},{'liste_key'=>1});
}

### Actions des boutons de la partie NOTATION

sub check_possible_assoc {
    my ($code)=@_;
    if(! -s absolu($projet{'options'}->{'listeetudiants'})) {
	my $dialog = Gtk2::MessageDialog
	    ->new_with_markup($w{'main_window'},
			      'destroy-with-parent',
			      'error','ok',
			      sprintf(__"Before associating names to papers, you must choose a students list file in tab \"%s\".",__"Data capture"));
	$dialog->run;
	$dialog->destroy;
    } elsif(!$projet{'options'}->{'liste_key'}) {
	my $dialog = Gtk2::MessageDialog
	    ->new_with_markup($w{'main_window'},
			      'destroy-with-parent',
			      'error','ok',
			      __("Please choose a key from primary keys in students list before association."));
	$dialog->run;
	$dialog->destroy;
    } elsif($code && ! $projet{'options'}->{'assoc_code'}) {
	my $dialog = Gtk2::MessageDialog
	    ->new_with_markup($w{'main_window'},
			      'destroy-with-parent',
			      'error','ok',
			      __("Please choose a code (made with LaTeX command \\AMCcode) before automatic association."));
	$dialog->run;
	$dialog->destroy;
    } else {
	return(1);
    }
    return(0);
}

# manual association 
sub associe {
    return() if(!check_possible_assoc(0));
    if(-f absolu($projet{'options'}->{'listeetudiants'})) {
	my $ga=AMC::Gui::Association::new('cr'=>absolu($projet{'options'}->{'cr'}),
					  'liste'=>absolu($projet{'options'}->{'listeetudiants'}),
					  'liste_key'=>$projet{'options'}->{'liste_key'},
					  'fichier-liens'=>absolu($projet{'options'}->{'association'}),
					  'global'=>0,
					  'assoc-ncols'=>$o{'assoc_ncols'},
					  'encodage_liste'=>bon_encodage('liste'),
					  'encodage_interne'=>$o{'encodage_interne'},
					  );
	if($ga->{'erreur'}) {
	    my $dialog = Gtk2::MessageDialog
		->new($w{'main_window'},
		      'destroy-with-parent',
		      'error','ok',
		      $ga->{'erreur'});
	    $dialog->run;
	    $dialog->destroy;
	}
    } else {
	my $dialog = Gtk2::MessageDialog
	    ->new($w{'main_window'},
		  'destroy-with-parent',
		  'info','ok',
		  sprintf(__"Before associating names to papers, you must choose a students list file in paragraph \"%s\".",__"Students identification"));
	$dialog->run;
	$dialog->destroy;
	
    }
}

# automatic association
sub associe_auto {
    return() if(!check_possible_assoc(1));

    commande('commande'=>["auto-multiple-choice","association-auto",
			  "--notes",absolu($projet{'options'}->{'notes'}),
			  "--notes-id",$projet{'options'}->{'assoc_code'},
			  "--liste",absolu($projet{'options'}->{'listeetudiants'}),
			  "--liste-key",$projet{'options'}->{'liste_key'},
			  "--encodage-liste",bon_encodage('liste'),
			  "--assoc",absolu($projet{'options'}->{'association'}),
			  "--encodage-interne",$o{'encodage_interne'},
			  "--debug",debug_file(),
	     ],
	     'texte'=>__"Automatic association...",
	     'fin'=>sub {
		 assoc_resultat();
	     },
	);
}

# automatic association finished : explain what to do after
sub assoc_resultat {
    dialogue_apprentissage('ASSOC_AUTO_OK','','',
			   __("Automatic association is now finished. You can ask for manual association to check that all is fine and, if necessary, read manually students names which have not been automatically identified."));
}

sub valide_cb {
    my ($var,$cb)=@_;
    my $cbc=$cb->get_active();
    if($cbc xor $$var) {
	$$var=$cbc;
	$projet{'options'}->{'_modifie'}=1;
	debug "* valide_cb";
    }
}

sub valide_options_correction {
    my ($ww,$o)=@_;
    my $name=$ww->get_name();
    debug "Valide OC from $name";
    valide_cb(\$projet{'options'}->{$name},$w{$name});
}

sub valide_options_notation {
    reprend_pref('notation',$projet{'options'});
}

sub valide_options_association {
    reprend_pref('pref_assoc',$projet{'options'});
}

sub valide_options_preparation {
    reprend_pref('pref_prep',$projet{'options'});
}

sub voir_notes {
    if(-f absolu($projet{'options'}->{'notes'})) {
	my $n=AMC::Gui::Notes::new('fichier'=>absolu($projet{'options'}->{'notes'}));
    } else {
	my $dialog = Gtk2::MessageDialog
	    ->new($w{'main_window'},
		  'destroy-with-parent',
		  'info','ok',
		  sprintf(__"Papers are not yet corrected: use button \"%s\".",__"Mark"));
	$dialog->run;
	$dialog->destroy;
	
    }
}

sub noter {
    if($projet{'options'}->{'maj_bareme'}) {
	commande('commande'=>["auto-multiple-choice","prepare",
			      "--n-copies",$projet{'options'}->{'nombre_copies'},
			      "--with",moteur_latex(),
			      "--debug",debug_file(),
			      "--progression-id",'bareme',
			      "--progression",1,
			      "--mode","b",
			      "--bareme",absolu($projet{'options'}->{'fichbareme'}),
			      absolu($projet{'options'}->{'texsrc'}),
			      ],
		 'texte'=>__"Extracting marking scale...",
		 'fin'=>\&noter_calcul,
		 'progres.id'=>'bareme');
    } else {
	noter_calcul();
    }
}

sub noter_calcul {
    commande('commande'=>["auto-multiple-choice","note",
			  "--debug",debug_file(),
			  "--cr",absolu($projet{'options'}->{'cr'}),
			  "--an-saved",absolu($an_saved),
			  "--bareme",absolu($projet{'options'}->{'fichbareme'}),
			  "-o",absolu($projet{'options'}->{'notes'}),
			  "--seuil",$projet{'options'}->{'seuil'},
			  
			  "--grain",$projet{'options'}->{'note_grain'},
			  "--arrondi",$projet{'options'}->{'note_arrondi'},
			  "--notemax",$projet{'options'}->{'note_max'},
			  "--plafond",$projet{'options'}->{'note_max_plafond'},
			  "--notemin",$projet{'options'}->{'note_min'},
			  
			  "--encodage-interne",$o{'encodage_interne'},
			  "--progression-id",'notation',
			  "--progression",1,
			  ],
	     'signal'=>2,
	     'texte'=>__"Computing marks...",
	     'progres.id'=>'notation',
	     'fin'=>sub {
		 noter_resultat();
	     },
	     );
}

sub noter_resultat {
    my $moy;
    my @codes=();
    if(-s absolu($projet{'options'}->{'notes'})) {
	debug "* reading marks";
	my $notes=eval { XMLin(absolu($projet{'options'}->{'notes'}),
			       'ForceArray'=>1,
			       'KeyAttr'=>['id'],
			       ) };
	if($notes) {
	    # recuperation de la moyenne
	    $moy=sprintf("%.02f",$notes->{'moyenne'}->[0]);
	    $w{'correction_result'}->set_markup("<span foreground=\"darkgreen\">".sprintf(__"Mean: %s",$moy)."</span>");
	    # recuperation des codes disponibles
	    @codes=(keys %{$notes->{'code'}});
	} else {
	    $w{'correction_result'}->set_markup("<span foreground=\"red\">".__("Unreadable marks")."</span>");
	}
	debug "Codes : ".join(',',@codes);
    } else {
	$w{'correction_result'}->set_markup("<span foreground=\"red\">".__("No marks computed")."</span>");
	push @codes,$projet{'options'}->{'assoc_code'}
	if($projet{'options'}->{'assoc_code'});
    }
# TRANSLATORS: you can omit the [...] part, just here to explain context
    $cb_stores{'assoc_code'}=cb_model(''=>__p("(none) [No code found in LaTeX file]"),
				      map { $_=>decode($o{'encodage_latex'},$_) } 
				      sort { $a cmp $b } (@codes));
    transmet_pref($gui,'pref_assoc',$projet{'options'},{},{'assoc_code'=>1});
}

sub visualise_correc {
    my $sel=$w{'correc_tree'}->get_selection()->get_selected_rows();
    #print "Correc $sel $correc_store\n";
    my $f=$correc_store->get($correc_store->get_iter($sel),CORREC_FILE);
    debug "Looking at $f...";
    commande_parallele($o{'img_viewer'},$f);
}

sub opt_symbole {
    my ($s)=@_;
    my $k=$s;
    my $type='none';
    my $color='red';

    $k =~ s/-/_/g;
    $type=$o{'symbole_'.$k.'_type'} if(defined($o{'symbole_'.$k.'_type'}));
    $color=$o{'symbole_'.$k.'_color'} if(defined($o{'symbole_'.$k.'_color'}));

    return("$s:$type/$color");
}

sub annote_copies {
    commande('commande'=>["auto-multiple-choice","annote",
			  pack_args("--debug",debug_file(),
				    "--progression-id",'annote',
				    "--progression",1,
				    "--projet",absolu('%PROJET/'),
				    "--projets",absolu('%PROJETS/'),
				    "--ch-sign",$o{'annote_chsign'},
				    "--cr",absolu($projet{'options'}->{'cr'}),
				    "--an-saved",absolu($an_saved),
				    "--notes",absolu($projet{'options'}->{'notes'}),
				    "--taille-max",$o{'taille_max_correction'},
				    "--bareme",absolu($projet{'options'}->{'fichbareme'}),
				    "--qualite",$o{'qualite_correction'},
				    "--line-width",$o{'symboles_trait'},
				    
				    "--indicatives",$o{'symboles_indicatives'},
				    "--symbols",join(',',map { opt_symbole($_); } (qw/0-0 0-1 1-0 1-1/)), 
			            "--position",$projet{'options'}->{'annote_position'},
			            "--pointsize-nl",$o{'annote_ps_nl'},
			            "--ecart",$o{'annote_ecart'},
			            "--verdict",$projet{'options'}->{'verdict'},
			            "--verdict-question",$projet{'options'}->{'verdict_q'},
			            "--fich-assoc",absolu($projet{'options'}->{'association'}),
			            "--fich-noms",absolu($projet{'options'}->{'listeetudiants'}),
			            "--noms-encodage",bon_encodage('liste'),
			  ($projet{'options'}->{'annote_rtl'} ? "--rtl" : "--no-rtl"),
                                   )
			  ],
	     'texte'=>__"Annotating papers...",
	     'progres.id'=>'annote',
	     'fin'=>sub { detecte_correc(); },
	     );
}

sub regroupement {

    valide_options_notation();

    commande('commande'=>["auto-multiple-choice","regroupe",
			  "--debug",debug_file(),
			  ($projet{'options'}->{'regroupement_compose'} ? "--compose" : "--no-compose"),
			  "--cr",absolu($projet{'options'}->{'cr'}),
			  "--an-saved",absolu($an_saved),
			  "--sujet",absolu($projet{'options'}->{'docs'}->[0]),
			  "--mep",absolu($projet{'options'}->{'mep'}),
			  "--mep-saved",absolu($mep_saved),
			  "--tex-src",absolu($projet{'options'}->{'texsrc'}),
			  "--with",moteur_latex(),
			  "--n-copies",$projet{'options'}->{'nombre_copies'},
			  "--progression-id",'regroupe',
			  "--progression",1,
			  "--modele",$projet{'options'}->{'modele_regroupement'},
			  "--fich-assoc",absolu($projet{'options'}->{'association'}),
			  "--fich-noms",absolu($projet{'options'}->{'listeetudiants'}),
			  "--noms-encodage",bon_encodage('liste'),

			  ],
	     'signal'=>2,
	     'texte'=>__"Grouping students annotated pages together...",
	     'progres.id'=>'regroupe',
	     );
}

sub view_dir {
    my ($dir)=@_;

    debug "Look at $dir";
    my $seq=0;
    my @c=map { $seq+=s/[%]d/$dir/g;$_; } split(/\s+/,$o{'dir_opener'});
    push @c,$dir if(!$seq);
    # nautilus attend des arguments dans l'encodage specifie par LANG & co.
    @c=map { encode($encodage_systeme,$_); } @c;

    commande_parallele(@c);
}

sub open_exports_dir {
    view_dir(absolu('%PROJET/exports/'));
}

sub open_templates_dir {
    view_dir($o{'rep_modeles'});
}

sub regarde_regroupements {
    view_dir(absolu($projet{'options'}->{'cr'})."/corrections/pdf");
}

###

sub activate_apropos {
    my $gap=Gtk2::GladeXML->new($glade_xml,'apropos','auto-multiple-choice');
    $gap->signal_autoconnect_from_package('main');
    for(qw/apropos/) {
	$w{$_}=$gap->get_widget($_);
    }
}

sub close_apropos {
    $w{'apropos'}->destroy();
}

sub activate_doc {
    my ($w,$lang)=@_;

    #print STDERR "$w / $lang\n";

    my $url='file://'.$hdocdir;
    $url.="auto-multiple-choice.$lang/index.html"
	if($lang && -f $hdocdir."auto-multiple-choice.$lang/index.html");

    my $seq=0;
    my @c=map { $seq+=s/[%]u/$url/g;$_; } split(/\s+/,$o{'html_browser'});
    push @c,$url if(!$seq);
    @c=map { encode($encodage_systeme,$_); } @c;
    
    commande_parallele(@c);
}

###

# mise a jour des zooms depuis le menu par ex.
sub activate_zoom_maj {
    if($projet{'_an_list'}->nombre()==0) {
	my $dialog = Gtk2::MessageDialog
	    ->new_with_markup($w{'main_window'},
			      'destroy-with-parent',
			      'error','ok',
			      __"No automatic data capture: no zoom to build...");
	$dialog->run;
	$dialog->destroy;      
	return(0);
    }

    commande('commande'=>["auto-multiple-choice","zooms",
			  "--debug",debug_file(),
			  "--projet",absolu('%PROJET/'),
			  "--projets",absolu('%PROJETS/'),
			  "--seuil",$projet{'options'}->{'seuil'},
			  "--n-procs",$o{'n_procs'},
			  "--an-saved",absolu($an_saved),
			  "--cr-dir",absolu($projet{'options'}->{'cr'}),
			  "--progression",1,
			  "--progression-id",'zooms',
			  ],
	     'texte'=>__"Re-extracting zooms...",
	     'progres.id'=>'zooms',
	     );
}

###

# transmet les preferences vers les widgets correspondants
# _c_ combo box (menu)
# _cb_ check button
# _ce_ combo box entry
# _col_ color chooser
# _f_ file name
# _s_ spin button
# _t_ text
# _v_ check button
# _x_ one line text

sub transmet_pref {
    my ($gap,$prefixe,$h,$alias,$seulement)=@_;

    for my $t (keys %$h) {
	if(!$seulement || $seulement->{$t}) {
	my $ta=$t;
	$ta=$alias->{$t} if($alias->{$t});

	my $wp=$gap->get_widget($prefixe.'_t_'.$ta);
	if($wp) {
	    $w{$prefixe.'_t_'.$t}=$wp;
	    $wp->get_buffer->set_text($h->{$t});
	}
	$wp=$gap->get_widget($prefixe.'_x_'.$ta);
	if($wp) {
	    $w{$prefixe.'_x_'.$t}=$wp;
	    $wp->set_text($h->{$t});
	}
	$wp=$gap->get_widget($prefixe.'_f_'.$ta);
	if($wp) {
	    $w{$prefixe.'_f_'.$t}=$wp;
	    if($wp->get_action =~ /-folder$/i) {
		$wp->set_current_folder($h->{$t});
	    } else {
		$wp->set_filename($h->{$t});
	    }
	}
	$wp=$gap->get_widget($prefixe.'_v_'.$ta);
	if($wp) {
	    $w{$prefixe.'_v_'.$t}=$wp;
	    $wp->set_active($h->{$t});
	}
	$wp=$gap->get_widget($prefixe.'_s_'.$ta);
	if($wp) {
	    $w{$prefixe.'_s_'.$t}=$wp;
	    $wp->set_value($h->{$t});
	}
	$wp=$gap->get_widget($prefixe.'_col_'.$ta);
	if($wp) {
	    $w{$prefixe.'_col_'.$t}=$wp;
	    $wp->set_color(Gtk2::Gdk::Color->parse($h->{$t}));
	}
	$wp=$gap->get_widget($prefixe.'_cb_'.$ta);
	if($wp) {
	    $w{$prefixe.'_cb_'.$t}=$wp;
	    $wp->set_active($h->{$t});
	}
	$wp=$gap->get_widget($prefixe.'_c_'.$ta);
	if($wp) {
	    $w{$prefixe.'_c_'.$t}=$wp;
	    if($cb_stores{$ta}) {
		debug "CB_STORE($t) ALIAS $ta modifie";
		$wp->set_model($cb_stores{$ta});
		my $i=model_id_to_iter($wp->get_model,COMBO_ID,$h->{$t});
		if($i) {
		    debug("[$t] find $i",
			  " -> ".$cb_stores{$ta}->get($i,COMBO_TEXT));
		    $wp->set_active_iter($i);
		}
	    } else {
		debug "no CB_STORE for $ta";
		$wp->set_active($h->{$t});
	    }
	}
	$wp=$gap->get_widget($prefixe.'_ce_'.$ta);
	if($wp) {
	    $w{$prefixe.'_ce_'.$t}=$wp;
	    if($cb_stores{$ta}) {
		debug "CB_STORE($t) ALIAS $ta changed";
		$wp->set_model($cb_stores{$ta});
	    }
	    my $we=$wp->get_children();
	    $we->set_text($h->{$t});
	    $w{$prefixe.'_x_'.$t}=$we;
	}
	debug "Key $t --> $ta : ".(defined($wp) ? "found widget $wp" : "NONE");
    }}
}

# met a jour les preferences depuis les widgets correspondants
sub reprend_pref {
    my ($prefixe,$h,$oprefix)=@_;
    $h->{'_modifie'}=($h->{'_modifie'} ? 1 : '');

    for my $t (keys %$h) {
	my $tgui=$t;
	$tgui =~ s/$oprefix$// if($oprefix);
	my $n;
	my $wp=$w{$prefixe.'_x_'.$tgui};
	if($wp) {
	    $n=$wp->get_text();
	    $h->{'_modifie'}.=",$t" if($h->{$t} ne $n);
	    $h->{$t}=$n;
	}
	$wp=$w{$prefixe.'_t_'.$tgui};
	if($wp) {
	    my $buf=$wp->get_buffer;
	    $n=$buf->get_text($buf->get_start_iter,$buf->get_end_iter,1);
	    $h->{'_modifie'}.=",$t" if($h->{$t} ne $n);
	    $h->{$t}=$n;
	}
	$wp=$w{$prefixe.'_f_'.$tgui};
	if($wp) {
	    if($wp->get_action =~ /-folder$/i) {
		if(-d $wp->get_filename()) {
		    $n=$wp->get_filename();
		} else {
		    $n=$wp->get_current_folder();
		}
	    } else {
		$n=$wp->get_filename();
	    }
	    $h->{'_modifie'}.=",$t" if($h->{$t} ne $n);
	    $h->{$t}=$n;
	}
	$wp=$w{$prefixe.'_v_'.$tgui};
	if($wp) {
	    $n=$wp->get_active();
	    $h->{'_modifie'}.=",$t" if($h->{$t} ne $n);
	    $h->{$t}=$n;
	}
	$wp=$w{$prefixe.'_s_'.$tgui};
	if($wp) {
	    $n=$wp->get_value();
	    $h->{'_modifie'}.=",$t" if($h->{$t} ne $n);
	    $h->{$t}=$n;
	}
	$wp=$w{$prefixe.'_col_'.$tgui};
	if($wp) {
	    $n=$wp->get_color()->to_string();
	    $h->{'_modifie'}.=",$t" if($h->{$t} ne $n);
	    $h->{$t}=$n;
	}
	$wp=$w{$prefixe.'_cb_'.$tgui};
	if($wp) {
	    $n=$wp->get_active();
	    $h->{'_modifie'}.=",$t" if($h->{$t} ne $n);
	    $h->{$t}=$n;
	}
	$wp=$w{$prefixe.'_c_'.$tgui};
	if($wp) {
	    if($wp->get_model) {
		if($wp->get_active_iter) {
		    $n=$wp->get_model->get($wp->get_active_iter,COMBO_ID);
		} else {
		    $n='';
		}
		#print "[$t] valeur=$n\n";
	    } else {
		$n=$wp->get_active();
	    }
	    $h->{'_modifie'}.=",$t" if($h->{$t} ne $n);
	    $h->{$t}=$n;
	}
    }
    
    debug "Changes : $h->{'_modifie'}";
}

sub change_methode_impression {
    if($w{'pref_x_print_command_pdf'}) {
	my $m='';
	if($w{'pref_c_methode_impression'}->get_active_iter) {
	    $m=$w{'pref_c_methode_impression'}->get_model->get($w{'pref_c_methode_impression'}->get_active_iter,COMBO_ID);
	}
	$w{'pref_x_print_command_pdf'}->set_sensitive($m eq 'commande');
    }
}

sub edit_preferences {
    my $gap=Gtk2::GladeXML->new($glade_xml,'edit_preferences','auto-multiple-choice');

    for(qw/edit_preferences pref_projet_tous pref_projet_annonce pref_x_print_command_pdf pref_c_methode_impression symboles_tree/) {
	$w{$_}=$gap->get_widget($_);
    }

    $w{'edit_preferences_manager'}=$gap;

    $gap->signal_autoconnect_from_package('main');

    # tableau type/couleurs pour correction

    for my $t (grep { /^pref(_projet)?_[xfcv]_/ } (keys %w)) {
	delete $w{$t};
    }
    transmet_pref($gap,'pref',\%o);
    transmet_pref($gap,'pref_projet',$projet{'options'}) if($projet{'nom'});

    # projet ouvert -> ne pas changer localisation
    if($projet{'nom'}) {
	$w{'pref_f_rep_projets'}->set_sensitive(0);
	$w{'pref_projet_annonce'}->set_label('<i>'.sprintf(__"Project \"%s\" preferences",$projet{'nom'}).'</i>.');
    } else {
	$w{'pref_projet_tous'}->set_sensitive(0);
	$w{'pref_projet_annonce'}->set_label('<i>'.__("Project preferences").'</i>');
    }

    change_methode_impression();
}

sub accepte_preferences {
    reprend_pref('pref',\%o);
    reprend_pref('pref_projet',$projet{'options'}) if($projet{'nom'});

    my %pm;
    my @gm;
    my %labels;

    if($projet{'nom'}) {
	%pm=map { $_=>1 } (split(/,/,$projet{'options'}->{'_modifie'}));
	@gm=grep { /^defaut_/ } (split(/,/,$o{'_modifie'}));

	for my $k (@gm) {
	    my $l=$w{'edit_preferences_manager'}->get_widget('label_'.$k);
	    $labels{$k}=$l->get_text() if($l);
	    my $kp=$k;
	    $kp =~ s/^defaut_//;
	    $l=$w{'edit_preferences_manager'}->get_widget('label_'.$kp);
	    $labels{$kp}=$l->get_text() if($l);
	}
    }

    $w{'edit_preferences'}->destroy();

    # modified default value ?
    if($projet{'nom'}) {
	debug "Modified (general): $o{'_modifie'}";
	debug "Modified (project): ".$projet{'options'}->{'_modifie'};
	debug "Labels: ".join(',',keys %labels);

	for my $k (@gm) {
	    my $kp=$k;
	    $kp =~ s/^defaut_//;

	    debug "Test G:$k / P:$kp";
	    if((!$pm{$kp}) && ($projet{'options'}->{$kp} ne $o{$k})) {
		# project option has NOT been modified, and the new
		# value of general default option is different from
		# project option. Ask the user for modifying also the
		# project option value
		$label_projet=$labels{$kp};
		$label_general=$labels{$k};

		debug "Ask user $label_general | $label_projet";

		if($label_projet && $label_general) {
		    my $dialog = Gtk2::MessageDialog
			->new_with_markup($w{'main_window'},
					  'destroy-with-parent',
					  'question','yes-no',
					  sprintf(__("You modified \"<b>%s</b>\" value, which is the default value used when creating new projects. Do you want to change also \"<b>%s</b>\" for the opened <i>%s</i> project?"),
					  $label_general,$label_projet,$projet{'nom'}));
		    my $reponse=$dialog->run;
		    $dialog->destroy;  

		    debug "Reponse: $reponse";
		    
		    if($reponse eq 'yes') {
			# change also project option value
			$projet{'options'}->{$kp}=$o{$k};
			$projet{'options'}->{'_modifie'}.=",$kp";
		    } 
    
		}
	    }
	}
    }

    if($projet{'nom'}) {
	for my $k (qw/note_min note_max note_grain/) {
	    $projet{'options'}->{$k} =~ s/\s+//g;
	}
    }

    sauve_pref_generales();

    test_commandes();

    if(defined($projet{'options'}->{'_modifie'})
       && $projet{'options'}->{'_modifie'} =~ /\bseuil\b/) {
	if($projet{'_an_list'}->nombre()>0) {
	    # mise a jour de la liste diagnostic
	    detecte_analyse('ids_m'=>[$projet{'_an_list'}->ids()]);

	    # recalcul des zooms ?
	    # this is only necessary with old-style zoom files:
	    # first check if there are some of them...

	    my $cr_dir=absolu($projet{'options'}->{'cr'});
	    opendir(my $dh,$cr_dir) || debug "ERROR: can't opendir $cr_dir: $!";
	    my @z = grep { /^zoom-/ && -f "$cr_dir/$_" } readdir($dh);
	    closedir $dh;

	    if(@z) {
		
		my $dialog = Gtk2::MessageDialog
		    ->new_with_markup($w{'main_window'},
				      'destroy-with-parent',
				      'question','yes-no',
				      sprintf(__"You changed parameter \"%s\".",__"darkness threshold")." "
				      .__("If you already captured data from scans, boxes zooms are no longer correctly grouped.")." "
				      .__("Do you want to re-build them?")." "
				      .__("It will take some time.")." "
				      .sprintf(__"You will be able to build them later with <i>%s</i> in menu <i>%s</i>.",__"Re-extract zooms",__"Tools"));
		my $reponse=$dialog->run;
		$dialog->destroy;      
		
		if($reponse eq 'yes') {
		    activate_zoom_maj();	    
		} 
	    }
	    
	}
    }
}

sub sauve_pref_generales {
    debug "Saving general preferences...";

    if(pref_xx_ecrit(\%o,'AMC',$o_file)) {
	my $dialog = Gtk2::MessageDialog
	    ->new($w{'main_window'},
		  'destroy-with-parent',
		  'error','ok',
		  __"Error writing to options file %s: %s"
		  ,$o_file,$!);
	$dialog->run;
	$dialog->destroy;      
    } else {
	$o{'_modifie'}=0;
    }
}

sub annule_preferences {
    debug "Canceling preferences modification";
    $w{'edit_preferences'}->destroy();
}

sub file_maj {
    my $f=shift;
    if($f && -f $f) {
	if(-r $f) {
	    my @s=stat($f);
	    return(decode('UTF-8',strftime("%x %X",localtime($s[9]))));
	} else {
	    return(__"unreadable");
	}
    } else {
	return(__"not found");
    }
}

sub detecte_documents {
    for my $i (0..2) {
	my $r='';
	my $f=absolu($projet{'options'}->{'docs'}->[$i]);
	$doc_store->set($doc_ligne[$i],DOC_MAJ,file_maj($f));
    }
}

sub detecte_mep {
    $w{'commande'}->show();
    $w{'avancement'}->set_text(__"Looking for detected layouts...");
    $w{'avancement'}->set_fraction(0);
    Gtk2->main_iteration while ( Gtk2->events_pending );

    $projet{'_mep_list'}->maj('progres'=>sub {
	$w{'avancement'}->set_pulse_step(.02);
	$w{'avancement'}->pulse();
	Gtk2->main_iteration while ( Gtk2->events_pending );
    },
		   );

    $mep_store->clear();

    $w{'onglet_saisie'}->set_sensitive($projet{'_mep_list'}->nombre()>0);

    my $ii=0;
    for my $i ($projet{'_mep_list'}->ids()) {
	my $iter=$mep_store->append;
	$mep_store->set($iter,MEP_ID,$i,MEP_PAGE,$projet{'_mep_list'}->attr($i,'page'),MEP_MAJ,file_maj($projet{'_mep_list'}->filename($i)));

	$ii++;
	$w{'avancement'}->set_fraction($ii/$projet{'_mep_list'}->nombre());
	if($ii % 50 ==0) {
	    Gtk2->main_iteration while ( Gtk2->events_pending );
	}
    }

    $projet{'_mep_defauts'}={$projet{'_mep_list'}->etudiants_defauts()};
    my @def=(keys %{$projet{'_mep_defauts'}});
    if(@def) {
	$w{'button_mep_warnings'}->show();
    } else {
	$w{'button_mep_warnings'}->hide();
    }

    $w{'avancement'}->set_text('');
    $w{'avancement'}->set_fraction(0);
    $w{'commande'}->hide();
    Gtk2->main_iteration while ( Gtk2->events_pending );
}

my %defect_text=(
    'NO_NAME'=>__("The \\namefield command is not used. Writing subjects without name field is not recommended."),
    'SEVERAL_NAMES'=>__("The \\namefield command is used several times for the same subject. This should not be the case, as each student should write his name only once."),
    'NO_BOX'=>__("No box to be ticked."),
    );

sub mep_warnings {
    my $m='';
    my @def=(keys %{$projet{'_mep_defauts'}});
    if(@def) {
	$m=__("Some potential defects were detected for this subject. Correct them in the LaTeX source and update the working documents.");
	for my $k (keys %defect_text) {
	    if($projet{'_mep_defauts'}->{$k}) {
		my @e=sort { $a <=> $b } (@{$projet{'_mep_defauts'}->{$k}});
		if(@e) {
		    $m.="\n<b>".$defect_text{$k}."</b> ".
			sprintf(__('(Concerns %1$d sheets, see for exemple sheet %2$d)'),1+$#e,$e[0]);
		    
		}
	    }
	}
    } else {
	# should not be possible to go there...
	return();
    }
    my $dialog = Gtk2::MessageDialog
	->new_with_markup($w{'main_window'},
			  'destroy-with-parent',
			  'warning','ok',
			  $m
	);
    $dialog->run;
    $dialog->destroy;

}

sub detecte_correc {
    my $cordir=absolu("cr/corrections/jpg");
    $correc_store->clear();
    my @corr=();

    if(opendir(DIR, $cordir)) {
	@corr = sort { file_triable($a) cmp file_triable($b) } 
	grep { /\.jpg$/ && -f "$cordir/$_" } readdir(DIR);
	closedir DIR;
	
	for my $f (@corr) {
	    my $iter=$correc_store->append;
	    $correc_store->set($iter,CORREC_FILE,"$cordir/$f",
			       CORREC_MAJ,file_maj("$cordir/$f"),
			       CORREC_ID,file2id($f));
	}
    } else {
	debug("JPEGS : Can't open directory $cordir : $!");
    }

    $w{'regroupement_corriges'}->set_sensitive($#corr>=0);
}

sub detecte_analyse {
    my (%oo)=(@_);

    debug "Detecting analysis / ".join(', ',map { $_."=".$oo{$_} } (keys %oo));

    $w{'commande'}->show();
    my $av_text=$w{'avancement'}->get_text();
    $w{'avancement'}->set_text(__"Looking for analysis...");
    $w{'avancement'}->set_fraction(0) if(!$oo{'interne'});
    Gtk2->main_iteration while ( Gtk2->events_pending );

    my @ids_m;

    if($oo{'ids_m'}) {
	@ids_m=@{$oo{'ids_m'}};
    } else {
	@ids_m=$projet{'_an_list'}->maj('progres'=>sub {
	    $w{'avancement'}->set_pulse_step(.1);
	    $w{'avancement'}->pulse();
	    Gtk2->main_iteration while ( Gtk2->events_pending );
	},
					);
    }

    if($oo{'premier'}) {
	@ids_m=$projet{'_an_list'}->ids();
	$diag_store->clear;
    }

    debug "IDS_M : ".join(' ',@ids_m);

    $w{'onglet_notation'}->set_sensitive($projet{'_an_list'}->nombre()>0);
    detecte_correc() if($projet{'_an_list'}->nombre()>0);

    my $ii=0;

  UNID: for my $i (@ids_m) {
      my $iter='';

      $ii++;

      # a ete efface ?
      if(! $projet{'_an_list'}->existe($i)) {
	  debug "Deleting $i";
	  $iter=model_id_to_iter($diag_store,DIAG_ID,$i);
	  if($iter) {
	      $diag_store->remove($iter);
	  } else {
	      debug "- not found";
	  }
      } else {

	  debug "ID=$i ::",Dumper($projet{'_an_list'}->{'dispos'}->{$i});
	  
	  # deja dans la liste ? sinon on rajoute...
	  
	  if(!$oo{'premier'}) {
	      $iter=model_id_to_iter($diag_store,DIAG_ID,$i);
	  }
	  $iter=$diag_store->append if(!$iter);
	  
	  my ($eqm,$eqm_coul)=$projet{'_an_list'}->mse_string($i,
							      $o{'seuil_eqm'},
							      'red');
	  my ($sens,$sens_coul)=$projet{'_an_list'}->sensibilite_string($i,$projet{'options'}->{'seuil'},
									$o{'seuil_sens'},
									'red');
	  
	  $diag_store->set($iter,
			   DIAG_ID,$i,
			   DIAG_ID_BACK,$projet{'_an_list'}->couleur($i),
			   DIAG_EQM,$eqm,
			   DIAG_EQM_BACK,$eqm_coul,
			   DIAG_MAJ,file_maj($projet{'_an_list'}->filename($i)),
			   DIAG_DELTA,$sens,
			   DIAG_DELTA_BACK,$sens_coul,
			   );
      }
	  
      $w{'avancement'}->set_fraction(0.9*$ii/(1+$#ids_m)) if(!$oo{'interne'});
      if($ii % 50 ==0) {
	  Gtk2->main_iteration while ( Gtk2->events_pending );
      }
  }
    
    # erreurs lors du traitement automatique des scans :

    $inconnu_store->clear();
    
    if($oo{'erreurs'}) {
	debug "Errors list : ".(1+$#{$oo{'erreurs'}})." items";
	for my $f (@{$oo{'erreurs'}}) {
	    debug "Inserting error : $f->[1] $f->[0]";
	    my $iter=$inconnu_store->append;
	    $inconnu_store->set($iter,
				INCONNU_SCAN,$f->[0],
				INCONNU_ID,$f->[1]);
	}
    }

    # resume

    my %r=$projet{'_mep_list'}->stats($projet{'_an_list'});
    my $tt='';
    if($r{'incomplet'}) {
	$tt=sprintf(__"Data capture from %d complete papers and <span foreground=\"red\">%d incomplete papers</span>",$r{'complet'},$r{'incomplet'});
    } else {
	$tt=sprintf("<span foreground=\"darkgreen\">".__("Data capture from %d complete papers")."</span>",$r{'complet'});
    }
    $w{'diag_result'}->set_markup($tt);

    # ID manquants :

    for my $i (@{$r{'manque_id'}}) {
	my $iter=$inconnu_store->append;
	$inconnu_store->set($iter,
			    INCONNU_SCAN,__"not found",
			    INCONNU_ID,$i);
    }
    

    $w{'avancement'}->set_text($av_text);
    $w{'avancement'}->set_fraction(0) if(!$oo{'interne'});
    $w{'commande'}->hide() if(!$oo{'interne'});
    Gtk2->main_iteration while ( Gtk2->events_pending );

    # dialogue apprentissage :

    if($oo{'apprend'}) {
	dialogue_apprentissage('SAISIE_AUTO','','',
			       __("Automatic data capture now completed.")." "
			       .($r{'incomplet'}>0 ? sprintf(__("It is not complete (missing pages from %d papers).")." ",$r{'incomplet'}) : '')
			       .__("You can analyse data capture quality with some indicators values in analysis list:")
			       ."\n"
			       .sprintf(__"- <b>%s</b> represents positioning gap for the four corner marks. Great value means abnormal page distortion.",__"MSE")
			       ."\n"
			       .sprintf(__"- great values of <b>%s</b> are seen when darkness ratio is very close to the threshold for some boxes.",__"sensitivity")
			       ."\n"
			       .sprintf(__"You can also look at the scan adjustment (<i>%s</i>) and ticked and unticked boxes (<i>%s</i>) using right-click on lines from table <i>%s</i>.",__"page adjustment",__"boxes zooms",__"Diagnosis")
			       );
    }

}

$w{'inconnu_tree'}->signal_connect('button_press_event' =>
				   sub {
				       my ($self, $event) = @_;
				       return 0 unless $event->type eq '2button-press';
				       return 0 unless $event->button == 1;
				       analyse_diagnostic();
				       return 1;
				   }
    );

sub analyse_diagnostic {
    my $iter=$w{'inconnu_tree'}->get_selection->get_selected;
    if($iter) {
	my $scan=$inconnu_store->get($iter,INCONNU_SCAN);
	
	my (undef,undef,$scan_n)=splitpath($scan);
	my $diagnostic_file=absolu('%PROJET/cr/diagnostic')."/".$scan_n.".png";
	
	if(-f $diagnostic_file) {
	    affiche_diagnostic($diagnostic_file);
	} else {
	    analyse_call('f'=>[$scan],
			 'text'=>__("Making diagnostic image..."),
			 'progres'=>'diagnostic',
			 'diagnostic'=>1,
			 'fin'=>sub {
			     affiche_diagnostic($diagnostic_file);
			 },
		);
	}
    }
}

sub affiche_diagnostic {
    my ($dfile)=@_;
    commande_parallele($o{'img_viewer'},$dfile);
}

sub set_source_tex {
    my ($importe)=@_;

    importe_source() if($importe);
    valide_source_tex();
}

sub source_latex_montre_nom {
    my $dialog = Gtk2::MessageDialog
	->new($w{'main_window'},
	      'destroy-with-parent',
	      'info','ok',
	      __"LaTeX source file for this project is:\n%s",
	      ($projet{'options'}->{'texsrc'} ? absolu($projet{'options'}->{'texsrc'}) : __"(no file)" ));
    $dialog->run;
    $dialog->destroy;
}

sub liste_montre_nom {
    my $dialog = Gtk2::MessageDialog
	->new($w{'main_window'},
	      'destroy-with-parent',
	      'info','ok',
	      __"Names list file for this project is:\n%s",
	      ($projet{'options'}->{'listeetudiants'} ? absolu($projet{'options'}->{'listeetudiants'}) : __"(no file)" ));
    $dialog->run;
    $dialog->destroy;
}

sub valide_source_tex {
    $projet{'options'}->{'_modifie'}=1;
    debug "* valide_source_tex";
    $w{'preparation_etats'}->set_sensitive(-f absolu($projet{'options'}->{'texsrc'}));

    if(is_local($projet{'options'}->{'texsrc'})) {
	$w{'edition_latex'}->show();
    } else {
	$w{'edition_latex'}->hide();
    }

    detecte_documents();
}

my $modeles_store;

sub charge_modeles {
    my ($store,$parent,$rep)=@_;

    return if(! -d $rep);

    my @all;
    my @ms;
    my @subdirs;

    if(opendir(DIR,$rep)) {
	@all=readdir(DIR);
	@ms=grep { /\.tgz$/ && -f $rep."/$_" } @all;
	@subdirs=grep { -d $rep."/$_" && ! /^\./ } @all;
	closedir DIR;
    } else {
	debug("MODELS : Can't open directory $rep : $!");
    }

    for my $sd (@subdirs) {
	my $nom=$sd;
	my $desc_text='';

	my $child = $store->append($parent);
	if(-f $rep."/$sd/directory.xml") {
	    my $d=XMLin($rep."/$sd/directory.xml");
	    $nom=$d->{'title'} if($d->{'title'});
	    $desc_text=$d->{'text'} if($d->{'text'});
	}
	$store->set($child,MODEL_NOM,$nom,
		    MODEL_PATH,'',
		    MODEL_DESC,$desc_text);
	charge_modeles($store,$child,$rep."/$sd");
    }

    for my $m (@ms) {
	my $child = $store->append($parent);

	my $nom=$m;
	$nom =~ s/\.tgz$//i;
	my $desc_text=__"(no description)";
	my $tar=Archive::Tar->new($rep."/$m");
	my @desc=grep { /description.xml$/ } ($tar->list_files());
	if($desc[0]) {
	    my $d=XMLin($tar->get_content($desc[0]),'SuppressEmpty'=>'');
	    $nom=$d->{'title'} if($d->{'title'});
	    $desc_text=$d->{'text'} if($d->{'text'});
	}
	debug "Adding model $m";
	debug "NAME=$nom DESC=$desc_text";
	$store->set($child,
		    MODEL_NOM,$nom,
		    MODEL_PATH,$rep."/$m",
		    MODEL_DESC,$desc_text);
    }
}

sub modele_dispo {
    my $iter=$w{'modeles_liste'}->get_selection()->get_selected();
    if($iter) {
	$w{'model_choice_button'}->set_sensitive($modeles_store->get($iter,MODEL_PATH) ? 1 : 0);
    } else {
	debug "No iter for models selection";
    }
}

sub path_from_tree {
    my ($store,$view,$f)=@_;
    my $i=undef;

    return(undef) if(!$f);

    my $d='';
    
    for my $pp (split(m:/:,$f)) {
	my $ipar=$i;
	$d.='/' if($d);
	$d.=$pp;
	$i=model_id_to_iter($store,TEMPLATE_FILES_PATH,$d);
	if(!$i) {
	    $i=$store->append($ipar);
	    $store->set($i,TEMPLATE_FILES_PATH,$d,
			TEMPLATE_FILES_FILE,$pp);
	}
    }

    $view->expand_to_path($store->get_path($i));
    return($i);
}

sub template_add_file {
    my ($store,$view,$f)=@_;

    # removes local part
    
    my $p_dir=absolu('%PROJET/');
    if($f =~ s:^\Q$p_dir\E::) {
	my $i=path_from_tree($store,$view,$f);
	return($i);
    } else {
	debug "Trying to add non local file: $f (local dir is $p_dir)";
	return(undef);
    }
}

sub make_template {

    if(!$projet{'nom'}) {
	debug "Make template: no opened project";
	return();
    }

    my $gt=Gtk2::GladeXML->new($glade_xml,'make_template','auto-multiple-choice');
    for (qw/make_template template_files_tree template_name template_file_name template_description template_file_name_warning mt_ok/) {
	$w{$_}=$gt->get_widget($_);
    }

    $w{'template_file_name_style'} = $w{'template_file_name'}->get_modifier_style->copy;

    $template_files_store->clear;

    $w{'template_files_tree'}->set_model($template_files_store);
	my $renderer=Gtk2::CellRendererText->new;
	my $column = Gtk2::TreeViewColumn->new_with_attributes(__"file",
							       $renderer,
							       text=> TEMPLATE_FILES_FILE );
    $w{'template_files_tree'}->append_column ($column);
    $w{'template_files_tree'}->get_selection->set_mode("multiple");

    # Detects files to include

    template_add_file($template_files_store,$w{'template_files_tree'},
		      absolu($projet{'options'}->{'texsrc'}));
    template_add_file($template_files_store,$w{'template_files_tree'},
		      fich_options($projet{'nom'}));

    # Waits for action
    
    $gt->signal_autoconnect_from_package('main');

    $resp=$w{'make_template'}->run();

    if($resp eq "1") {

	projet_check_and_save();

	# Creates template

	my $tfile=$o{'rep_modeles'}.'/'.$w{'template_file_name'}->get_text().".tgz";
	my $tar=Archive::Tar->new();
	$template_files_store->foreach(\&add_to_archive,[$tar]);

	# Description

	my $buf=$w{'template_description'}->get_buffer;

	my $desc='';
	my $writer=new XML::Writer(OUTPUT=>\$desc,ENCODING=>'utf-8');
	$writer->xmlDecl("UTF-8");
	$writer->startTag('description');
	$writer->dataElement('title',$w{'template_name'}->get_text());
	$writer->dataElement('text',$buf->get_text($buf->get_start_iter,$buf->get_end_iter,1));
	$writer->endTag('description');
	$writer->end();

	$tar->add_data('description.xml',encode_utf8($desc));

	$tar->write($tfile,COMPRESS_GZIP);
    }

    $w{'make_template'}->destroy;
}

sub add_to_archive {
    my ($store,$path,$iter,$data)=@_;
    my ($tar)=@$data;

    my $f=$store->get($iter,TEMPLATE_FILES_PATH);
    my $af=absolu("%PROJET/$f");

    return(0) if($f eq 'description.xml');

    if(-f $af) {
	debug "Adding to template archive: $f\n";
	my $tf=Archive::Tar::File->new( file => $af);
	$tf->rename($f);
	$tar->add_files($tf);
    }

    return(0);
}

sub template_filename_verif {
    restricted_check($w{'template_file_name'},$w{'template_file_name_style'},
		     $w{'template_file_name_warning'},"a-zA-Z0-9_+-");
    my $t=$w{'template_file_name'}->get_text();
    my $tfile=$o{'rep_modeles'}.'/'.$t.".tgz";
    $w{'mt_ok'}->set_sensitive($t && !-e $tfile);
}

sub make_template_add {
    my $fs=Gtk2::FileSelection->new(__"Add files to template");
    $fs->set_filename(absolu('%PROJET/'));
    $fs->set_select_multiple(1);
    $fs->hide_fileop_buttons;

    my $err=0;
    my $resp=$fs->run();
    if($resp eq 'ok') {
	for my $f ($fs->get_selections()) {
	    $err++ 
		if(!defined(template_add_file($template_files_store,$w{'template_files_tree'},$f)));
	}
    }
    $fs->destroy();

    if($err) {
	my $dialog=Gtk2::MessageDialog
	    ->new_with_markup($w{'make_template'},
			      'destroy-with-parent',
			      'error','ok',
			      __("When making a template, you can only add files that are within the project directory."));
	$dialog->run();
	$dialog->destroy();
    }
}

sub make_template_del {
    my @i=();
    for my $path ($w{'template_files_tree'}->get_selection->get_selected_rows) {
	push @i,$template_files_store->get_iter($path);
    }
    for(@i) {
	$template_files_store->remove($_);
    }
}

sub n_fich {
    my ($dir)=@_;

    if(opendir(NFICH,$dir)) {
	my @f=grep { ! /^\./ } readdir(NFICH);
	closedir(NFICH);

	return(1+$#f,"$dir/$f[0]");
    } else {
	debug("N_FICH : Can't open directory $dir : $!");
 	return(0);
    }
}

sub source_latex_choisir {

    my %oo=@_;
    my $texsrc='';

    if(!$oo{'nom'}) {
	debug "ERR: Empty name for source_latex_choisir";
	return(0,'');
    }

    if(-e $o{'rep_projets'}."/".$oo{'nom'}) {
	debug "ERR: existing project directory $oo{'nom'} for source_latex_choisir";
	return(0,'');
    }

    my %bouton=();

    if($oo{'type'}) {
	$bouton{$oo{'type'}}=1;
    } else {
	
	# fenetre de choix du source latex
	
	my $gap=Gtk2::GladeXML->new($glade_xml,'source_latex_dialog','auto-multiple-choice');
	
	my $dialog=$gap->get_widget('source_latex_dialog');
	
	my $reponse=$dialog->run();
	
	for(qw/new choix vide zip/) {
	    $bouton{$_}=$gap->get_widget('sl_type_'.$_)->get_active();
	    debug "Bouton $_" if($bouton{$_});
	}
	
	$dialog->destroy();
	
	debug "RESPONSE=$reponse";
	
	return(0,'') if(!$reponse);
    }

    # actions apres avoir choisi le type de source latex a utiliser

    if($bouton{'new'}) {
	
	# choix d'un modele

	$gap=Gtk2::GladeXML->new($glade_xml,'source_latex_modele','auto-multiple-choice');
	$gap->signal_autoconnect_from_package('main');

	for(qw/source_latex_modele modeles_liste modeles_description model_choice_button mlist_separation/) {
	    $w{$_}=$gap->get_widget($_);
	}

	$modeles_store = Gtk2::TreeStore->new('Glib::String',
					      'Glib::String',
					      'Glib::String');
	
	charge_modeles($modeles_store,undef,$o{'rep_modeles'}) if($o{'rep_modeles'});

	charge_modeles($modeles_store,undef,amc_specdir('models'));

	$w{'modeles_liste'}->set_model($modeles_store);
	my $renderer=Gtk2::CellRendererText->new;
	my $column = Gtk2::TreeViewColumn->new_with_attributes(__"template",
							       $renderer,
							       text=> MODEL_NOM );
	$w{'modeles_liste'}->append_column ($column);
	$w{'modeles_liste'}->get_selection->signal_connect("changed",\&source_latex_mmaj);

	$w{'mlist_separation'}->set_position(.5*$w{'mlist_separation'}->get_property('max-position'));
	$w{'mlist_separation'}->child1_resize(1);
	$w{'mlist_separation'}->child2_resize(1);

	$reponse=$w{'source_latex_modele'}->run();

	debug "Dialog modele : $reponse";

	# le modele est choisi : l'installer

	my $mod;

	if($reponse) {
	    my $iter=$w{'modeles_liste'}->get_selection()->get_selected();
	    $mod=$modeles_store->get($iter,MODEL_PATH) if($iter);
	}

	$w{'source_latex_modele'}->destroy();

	return(0,'') if(!$reponse);

	if($mod) {
	    debug "Installing model $mod";
	    return(source_latex_choisir('type'=>'zip','fich'=>$mod,
					'decode'=>1,'nom'=>$oo{'nom'}));
	} else {
	    debug "No model";
	    return(0,'');
	}

    } elsif($bouton{'choix'}) {

	# choisir un fichier deja present

	$gap=Gtk2::GladeXML->new($glade_xml,'source_latex_choix','auto-multiple-choice');

	for(qw/source_latex_choix/) {
	    $w{$_}=$gap->get_widget($_);
	}
	$w{'source_latex_choix'}->set_current_folder($home_dir);

	my $filtre_latex=Gtk2::FileFilter->new();
	$filtre_latex->set_name(__"LaTeX file (*.tex)");
        $filtre_latex->add_pattern("*.tex");
        $filtre_latex->add_pattern("*.TEX");
	$w{'source_latex_choix'}->add_filter($filtre_latex);
	
	$reponse=$w{'source_latex_choix'}->run();

	my $f=$w{'source_latex_choix'}->get_filename();

	$w{'source_latex_choix'}->destroy();

	return(0,'') if(!$reponse);

	$texsrc=relatif($f,$oo{'nom'});
	debug "Source LaTeX $f";

    } elsif($bouton{'zip'}) {

	my $fich;

	if($oo{'fich'}) {
	    $fich=$oo{'fich'};
	} else {
	    
	    # choisir un fichier ZIP
	    
	    $gap=Gtk2::GladeXML->new($glade_xml,'source_latex_choix_zip','auto-multiple-choice');
	    
	    for(qw/source_latex_choix_zip/) {
		$w{$_}=$gap->get_widget($_);
	    }
	    $w{'source_latex_choix_zip'}->set_current_folder($home_dir);
	    
	    my $filtre_zip=Gtk2::FileFilter->new();
	    $filtre_zip->set_name(__"Archive (zip, tgz)");
	    $filtre_zip->add_pattern("*.zip");
	    $filtre_zip->add_pattern("*.tgz");
	    $filtre_zip->add_pattern("*.TGZ");
	    $filtre_zip->add_pattern("*.ZIP");
	    $w{'source_latex_choix_zip'}->add_filter($filtre_zip);
	    
	    $reponse=$w{'source_latex_choix_zip'}->run();
	    
	    $fich=$w{'source_latex_choix_zip'}->get_filename();
	    
	    $w{'source_latex_choix_zip'}->destroy();
	    
	    return(0,'') if(!$reponse);
	}

	# cree un repertoire temporaire pour dezipper

	my $temp_dir = tempdir( DIR=>tmpdir(),CLEANUP => 1 );

	my $rv=0;

	my @cmd;

	if($fich =~ /\.zip$/i) {
	    @cmd=("unzip","-d",$temp_dir,$fich);
	} else {
	    @cmd=("tar","-x","-v","-z","-f",$fich,"-C",$temp_dir);
	}

	debug "Extracting archive files\nFROM: $fich\nWITH: ".join(' ',@cmd);
	if(open(UNZIP,"-|",@cmd) ) {
	    while(<UNZIP>) {
		debug $_;
	    }
	    close(UNZIP);
	} else {
	    $rv=1;
	}

	my ($n,$suivant)=n_fich($temp_dir);

	if($rv || $n==0) {
	    my $dialog = Gtk2::MessageDialog
		->new_with_markup($w{'main_window'},
				  'destroy-with-parent',
				  'error','ok',
				  sprintf(__"Nothing extracted from archive %s. Check it.",$fich));
	    $dialog->run;
	    $dialog->destroy;
	    return(0,'');
	} else {
	    # unzip OK
	    # vire les repertoires intermediaires :

	    while($n==1 && -d $suivant) {
		debug "Changing root directory : $suivant";
		$temp_dir=$suivant;
		($n,$suivant)=n_fich($temp_dir);
	    }

	    # bouge les fichiers la ou il faut

	    my $hd=$o{'rep_projets'}."/".$oo{'nom'};

	    mkdir($hd) if(! -e $hd);

	    my @archive_files;
	    
	    if(opendir(MVR,$temp_dir)) {
		@archive_files=grep { ! /^\./ } readdir(MVR);
		closedir(MVR);
	    } else {
		debug("ARCHIVE : Can't open $temp_dir : $!");
	    }

	    my $latex;

	    for my $ff (@archive_files) {
		debug "Moving to project: $ff";
		if($ff =~ /\.tex$/i) {
		    $latex=$ff;
		    if($oo{'decode'}) {
			debug "Decoding $ff...";
			move("$temp_dir/$ff","$temp_dir/$ff.0enc");
			copy_latex("$temp_dir/$ff.0enc","$temp_dir/$ff");
		    }
		}
		if(system("mv","$temp_dir/$ff","$hd/$ff") != 0) {
		    debug "ERR: Move failed: $temp_dir/$ff --> $hd/$ff -- $!";
		    debug "(already exists)" if(-e "$hd/$ff");
		}
	    }

	    if($latex) {
		$texsrc="%PROJET/$latex";
		debug "LaTeX found : $latex";
	    }

	    return(2,$texsrc);
	}

    } elsif($bouton{'vide'}) {

	my $hd=$o{'rep_projets'}."/".$oo{'nom'};
	
	mkdir($hd) if(! -e $hd);

	$texsrc='source.tex';
	my $sl="$hd/$texsrc";

	# creation fichier vide

	if(! open(FV,">$sl")) {
	    debug "Error opening $sl : $!";
	    return(0,'');
	}
	close(FV);

    } else {
	return(0,'');
    }

    return(1,$texsrc);
    
}

sub source_latex_mmaj {
    my $iter=$w{'modeles_liste'}->get_selection()->get_selected();
    my $desc='';

    $desc=$modeles_store->get($iter,MODEL_DESC) if($iter);
    $w{'modeles_description'}->get_buffer->set_text($desc);
}


# copie en changeant eventuellement d'encodage
sub copy_latex {
    my ($src,$dest)=@_;
    # 1) reperage du inputenc dans le source
    my $i='';
    open(SRC,$src);
  LIG: while(<SRC>) {
      s/%.*//;
      if(/\\usepackage\[([^\]]*)\]\{inputenc\}/) {
	  $i=$1;
	  last LIG;
      }
  }
    close(SRC);

    my $ie=get_enc($i);
    my $id=get_enc($o{'encodage_latex'});
    if($ie && $id && $ie->{'iso'} ne $id->{'iso'}) {
	debug "Reencoding $ie->{'iso'} => $id->{'iso'}";
	open(SRC,"<:encoding($ie->{'iso'})",$src) or return('');
	open(DEST,">:encoding($id->{'iso'})",$dest) or close(SRC),return('');
	while(<SRC>) {
	    chomp;
	    s/\\usepackage\[([^\]]*)\]\{inputenc\}/\\usepackage[$id->{'inputenc'}]{inputenc}/;
	    print DEST "$_\n";
	}
	close(DEST);
	close(SRC);
	return(1);
    } else {
	return(copy($src,$dest));
    }
}

sub importe_source {
    my ($fxa,$fxb,$fb) = splitpath($projet{'options'}->{'texsrc'});
    my $dest=absolu($fb);

    # fichier deja dans le repertoire projet...
    return() if(is_local($projet{'options'}->{'texsrc'},1));

    if(-f $dest) {
	my $dialog = Gtk2::MessageDialog
	    ->new($w{'main_window'},
		  'destroy-with-parent',
		  'error','yes-no',
		  __("File %s already exists in project directory: do you wnant to replace it?")." "
		  .__("Click yes to replace it and loose pre-existing contents, or No to cancel source file import."),$fb);
	my $reponse=$dialog->run;
	$dialog->destroy;      

	if($reponse eq 'no') {
	    return(0);
	} 
    }

    if(copy_latex(absolu($projet{'options'}->{'texsrc'}),$dest)) {
	$projet{'options'}->{'texsrc'}=relatif($dest);
	set_source_tex();
	my $dialog = Gtk2::MessageDialog
	    ->new($w{'main_window'},
		  'destroy-with-parent',
		  'info','ok',
		  __("LaTeX file has been copied to project directory.")." ".sprintf(__"You can now edit it with button \"%s\" or with any editor.",__"Edit LaTeX file"));
	$dialog->run;
	$dialog->destroy;   
    } else {
	my $dialog = Gtk2::MessageDialog
	    ->new($w{'main_window'},
		  'destroy-with-parent',
		  'error','ok',
		  __"Error copying source file: %s",$!);
	$dialog->run;
	$dialog->destroy;      
    }
}

sub edite_source {
    my $f=absolu($projet{'options'}->{'texsrc'});
    debug "Editing $f...";
    commande_parallele($o{'tex_editor'},$f);
}

sub valide_projet {
    set_source_tex();

    $projet{'_mep_list'}=AMC::MEPList::new(absolu($projet{'options'}->{'mep'}),
					   'brut'=>1,
					   'saved'=>absolu($mep_saved));

    detecte_mep();

    $projet{'_an_list'}=AMC::ANList::new(absolu($projet{'options'}->{'cr'}),
					 'brut'=>1,
					 'saved'=>absolu($an_saved));
    detecte_analyse('premier'=>1);

    debug "Correction options : MB".$projet{'options'}->{'maj_bareme'};
    $w{'maj_bareme'}->set_active($projet{'options'}->{'maj_bareme'});

    transmet_pref($gui,'notation',$projet{'options'});

    my $t=$w{'main_window'}->get_title();
    $t.= ' - '.sprintf(__('project %s'),$projet{'nom'})
        if(!($t =~ s/-.*/- projet $projet{'nom'}/));
    $w{'main_window'}->set_title($t);

    noter_resultat();

    valide_liste('noinfo'=>1,'nomodif'=>1);

    transmet_pref($gui,'export',$projet{'options'});
    transmet_pref($gui,'pref_prep',$projet{'options'});
}

sub projet_ouvre {
    my ($proj,$deja)=(@_);

    my $new_source=0;
    
    # ouverture du projet $proj. Si $deja==1, alors il faut le creer

    if($proj) {
	my ($ok,$texsrc);
	
	# choix fichier latex si nouveau projet...
	if($deja) {
	    ($ok,$texsrc)=source_latex_choisir('nom'=>$proj);
	    if(!$ok) {
		return(0);
	    }
	    if($ok==1) {
		$new_source=1;
	    } elsif($ok==2) {
		$deja='';
	    }
	}

	quitte_projet();
	$projet{'nom'}=$proj;
	$projet{'options'}->{'texsrc'}=$texsrc;

	if(!$deja) {

	    if(-f fich_options($proj)) {
		debug "Reading options for project $proj...";
		
		$projet{'options'}={pref_xx_lit(fich_options($proj))};
		
		# pour effacer des trucs en trop venant d'un bug anterieur...
		for(keys %{$projet{'options'}}) {
		    delete($projet{'options'}->{$_}) 
			if($_ !~ /^ext_/ && !exists($projet_defaut{$_}));
		}
		debug "Read options:",
		Dumper(\%projet);
	    } else {
		debug "No options file...";
	    }
	}
	
	$projet{'nom'}=$proj;

	# creation du repertoire et des sous-repertoires de projet

	for my $sous ('',qw:cr cr/corrections cr/corrections/jpg cr/corrections/pdf cr/zooms cr/diagnostic mep scans exports:) {
	    my $rep=$o{'rep_projets'}."/$proj/$sous";
	    if(! -x $rep) {
		debug "Creating directory $rep...";
		mkdir($rep);
	    }
	}

	# recuperation des options par defaut si elles ne sont pas encore definies dans la conf du projet
    
	for my $k (keys %projet_defaut) {
	    if(! exists($projet{'options'}->{$k})) {
		if($o{'defaut_'.$k}) {
		    $projet{'options'}->{$k}=$o{'defaut_'.$k};
		    debug "New parameter (default) : $k";
		} else {
		    $projet{'options'}->{$k}=$projet_defaut{$k};
		    debug "New parameter : $k";
		}
	    }
	}

	$w{'onglets_projet'}->set_sensitive(1);

	$w{'menu_outils'}->set_sensitive(1);

	valide_projet();

	$projet{'options'}->{'_modifie'}='';

	set_source_tex(1) if($new_source);

	return(1);
    }
}

sub quitte_projet {
    if($projet{'nom'}) {
	
	valide_options_notation();
	
	if($projet{'options'}->{'_modifie'}
	   || $projet{'options'}->{'_modifie_ok'}) {
	    my $save=1;
	    if($projet{'options'}->{'_modifie'}) {
		my $dialog = Gtk2::MessageDialog
		    ->new_with_markup($w{'main_window'},
				      'destroy-with-parent',
				      'question','yes-no',
				      sprintf(__"You did not save project <i>%s</i> options, which have been modified: do you want to save them before leaving?",$projet{'nom'}));
		my $reponse=$dialog->run;
		$dialog->destroy;      
		
		if($reponse ne 'yes') {
		    $save='';
		} 
	    }
	    projet_sauve() if($save);
	}

	%projet=();
    }
}

sub quitter {
    my $reponse='';

    quitte_projet();

    if($o{'conserve_taille'}) {
	my ($x,$y)=$w{'main_window'}->get_size();
	if(!$o{'taille_x_main'} || !$o{'taille_y_main'}
	   || $x != $o{'taille_x_main'} || $y != $o{'taille_y_main'}) {
	    $o{'taille_x_main'}=$x;
	    $o{'taille_y_main'}=$y;
	    $o{'_modifie_ok'}=1;
	}
    }

    if($o{'_modifie'} || $o{'_modifie_ok'}) {
	if($o{'_modifie'}) {
	    my $dialog = Gtk2::MessageDialog
		->new_with_markup($w{'main_window'},
				  'destroy-with-parent',
				  'question','yes-no',
				  __"You did not save main options, which have been modified: do you want to save them before leaving?");
	    $reponse=$dialog->run;
	    $dialog->destroy;      
	}
	
	if($reponse eq 'yes' || !$o{'_modifie'}) {
	    sauve_pref_generales();
	} 
    }

    Gtk2->main_quit;
    
}

sub bug_report {
    my $dialog = Gtk2::MessageDialog
	->new_with_markup($w{'main_window'},
			  'destroy-with-parent',
			  'info','ok',
			  __("In order to send a useful bug report, please attach the following documents:")."\n"
			  ."- ".__("an archive (in some compressed format, like ZIP, 7Z, TGZ...) containing the <b>project directory</b>, <b>scan files</b> and <b>configuration directory</b> (.AMC.d in home directory), so as to reproduce and analyse this problem.")."\n"
			  ."- ".__("the <b>log file</b> produced when the debugging mode (in Help menu) is checked. Please try to reproduce the bug with this mode activated.")."\n\n"
			  .sprintf(__("Bug reports can be filled at %s or sent to %s"),"<tt>https://gna.org/support/?group=auto-qcm&amp;func=additem</tt>",'<tt>paamc@passoire.fr</tt>')
	);
    $dialog->run;
    $dialog->destroy;
}

$gui->signal_autoconnect_from_package('main');

if($o{'conserve_taille'} && $o{'taille_x_main'} && $o{'taille_y_main'}) {
    $w{'main_window'}->resize($o{'taille_x_main'},$o{'taille_y_main'});
}

###

projet_ouvre($ARGV[0]);

#######################################
# For MacPorts with latexfree variant, for example

if("@/LATEX_FREE/@" =~ /(1|true|yes)/i) {
    my $message='';
    if(!commande_accessible("kpsewhich")) {
	$message=sprintf(__("I don't find the command %s."),"kpsewhich")
	    .__("Perhaps LaTeX is not installed?");
    } else {
	if(!get_sty()) {
	    $message=__("The style file automultiplechoice.sty seems to be unreachable. Try to use command 'auto-multiple-choice latex-link' as root to fix this.");
	}
    }
    if($message) {
	my $dialog = Gtk2::MessageDialog
	    ->new($w{'main_window'},
		  'destroy-with-parent',
		  'error','ok',$message);
	$dialog->run;
	$dialog->destroy;
    }
}

#######################################

test_commandes();

Gtk2->main();

1;

__END__

