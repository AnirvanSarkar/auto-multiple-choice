#! /usr/bin/perl -w
#
# Copyright (C) 2008-2021 Alexis Bienven√ºe <paamc@passoire.fr>
#
# This file is part of Auto-Multiple-Choice
#
# Auto-Multiple-Choice is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 2 of
# the License, or (at your option) any later version.
#
# Auto-Multiple-Choice is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Auto-Multiple-Choice.  If not, see
# <http://www.gnu.org/licenses/>.

use warnings;
use 5.012;

use Getopt::Long;

use Gtk3 -init;

use Glib::Object::Introspection;
use Glib qw/TRUE FALSE/;

use XML::Simple;
use IO::File;
use IO::Select;
use POSIX qw/strftime/;
use Time::Local;
use Cwd;
use File::Spec::Functions
  qw/splitpath catpath splitdir catdir catfile rel2abs tmpdir/;
use File::Temp qw/ tempfile tempdir /;
use File::Copy;
use File::Path qw/remove_tree/;
use File::Find;
use Archive::Tar;
use Archive::Tar::File;
use Encode;
use Unicode::Normalize;
use I18N::Langinfo qw(langinfo CODESET);
use Locale::Language;
use Text::ParseWords;

use Module::Load;
use Module::Load::Conditional qw/check_install/;

use AMC::Basic;
use AMC::Config;
use AMC::Data;
use AMC::DataModule::capture ':zone';
use AMC::DataModule::report ':const';
use AMC::Encodings;
use AMC::FileMonitor;
use AMC::Gui::APropos;
use AMC::Gui::Association;
use AMC::Gui::AutoCapture;
use AMC::Gui::ChooseColumns;
use AMC::Gui::Cleanup;
use AMC::Gui::Commande;
use AMC::Gui::CreateProject;
use AMC::Gui::FilterDetails;
use AMC::Gui::Learning;
use AMC::Gui::Mailing;
use AMC::Gui::Manuel;
use AMC::Gui::Notes;
use AMC::Gui::Overwritten;
use AMC::Gui::Postcorrect;
use AMC::Gui::Preferences;
use AMC::Gui::Prefs;
use AMC::Gui::Printing;
use AMC::Gui::ProjectManager;
use AMC::Gui::SelectStudents;
use AMC::Gui::StudentsList;
use AMC::Gui::Template;
use AMC::Gui::Unrecognized;
use AMC::Gui::WindowSize;
use AMC::Gui::Zooms;
use AMC::Path;
use AMC::Print;
use AMC::Scoring;
use AMC::State;

use Data::Dumper;

use constant {
    DOC_TITRE => 0,
    DOC_MAJ   => 1,

    MEP_PAGE => 0,
    MEP_ID   => 1,
    MEP_MAJ  => 2,

    DIAG_ID         => 0,
    DIAG_ID_BACK    => 1,
    DIAG_MAJ        => 2,
    DIAG_MAJ_NUM    => 3,
    DIAG_EQM        => 4,
    DIAG_EQM_BACK   => 5,
    DIAG_DELTA      => 6,
    DIAG_DELTA_BACK => 7,
    DIAG_ID_STUDENT => 8,
    DIAG_ID_PAGE    => 9,
    DIAG_ID_COPY    => 10,
    DIAG_SCAN_FILE  => 11,
};

my $libnotify_error = '';

Gtk3::IconTheme::get_default->prepend_search_path( amc_specdir('icons') );
Gtk3::Window::set_default_icon_list(
    [
        map {
            Gtk3::IconTheme::get_default->load_icon( "auto-multiple-choice",
                $_, "force-svg" )
        } ( 8, 16, 32, 48, 64, 128 )
    ]
);

use_gettext;
use_amc_plugins();

POSIX::setlocale( &POSIX::LC_NUMERIC, "C" );

my $debug      = 0;
my $debug_file = '';
my $do_nothing = 0;

my $profile     = '';
my $project_dir = '';

GetOptions(
    "debug!"       => \$debug,
    "debug-file=s" => \$debug_file,
    "profile=s"    => \$profile,
    "p=s"          => \$project_dir,
    "do-nothing!"  => \$do_nothing,
);

sub set_debug_mode {
    my ($debug) = @_;
    set_debug($debug);
    if ($debug) {
        my $date = strftime( "%c", localtime() );
        debug( '#' x 40 );
        debug "# DEBUG - $date";
        debug( '#' x 40 );
        debug "GUI module is located at " . __FILE__;
    }
}

if ( $debug || $debug_file ) {
    set_debug_mode( $debug_file || 'new' );
    print "DEBUG ==> " . debug_file() . "\n";
}

debug_pm_version("Gtk3");

my %w = ();

my $glade_base = __FILE__;
$glade_base =~ s/\.p[ml]$/-/i;

my $home_dir         = Glib::get_home_dir();
my $encodage_systeme = langinfo( CODESET() );

my $shortcuts = AMC::Path::new( home_dir => $home_dir );
my $config    = AMC::Config::new(
    shortcuts => $shortcuts,
    home_dir  => $home_dir,
    profile   => $profile
);
my $prefs = AMC::Gui::Prefs::new(
    shortcuts   => $shortcuts,
    alternate_w => \%w,
    config      => $config
);

my $monitor = AMC::FileMonitor->new();

my @export_modules = @{ $config->{export_modules} };

# Reads filter plugins list

my @filter_modules = perl_module_search('AMC::Filter::register');
for my $m (@filter_modules) {
    load("AMC::Filter::register::$m");
}
@filter_modules = sort {
    "AMC::Filter::register::$a"->weight <=> "AMC::Filter::register::$b"->weight
} @filter_modules;

sub best_filter_for_file {
    my ($file) = @_;
    my $mmax   = '';
    my $max    = -10;
    for my $m (@filter_modules) {
        my $c = "AMC::Filter::register::$m"->claim($file);
        if ( $c > $max ) {
            $max  = $c;
            $mmax = $m;
        }
    }
    return ($mmax);
}

# -----------------

## Notifications

sub notify_end_of_work {
    my ( $action, $message ) = @_;
    if ( $config->get( 'notify_' . $action ) ) {
        if ( $config->get('notify_desktop') ) {
            if ($libnotify_error) {
                debug "Notification ignored: $libnotify_error";
            } else {
                eval {
                    my $notification =
                      Notify::Notification->new( 'Auto Multiple Choice',
                        $message, '@/ICONSDIR/@/auto-multiple-choice.svg' );
                    $notification->show;
                };
                $libnotify_error = $@;
            }
        }
        if ( $config->get('notify_command') ) {
            my @cmd = map { s/[%]m/$message/g; s/[%]a/$action/g; $_; }
              quotewords( '\s+', 0, $config->get('notify_command') );
            if ( commande_accessible( $cmd[0] ) ) {
                commande_parallele(@cmd);
            } else {
                debug
                  "ERROR: command '$cmd[0]' not found when trying to notify";
            }
        }
    }
}

# Test whether the magick perl package is installed

sub test_magick {
    if ( !magick_perl_module(1) ) {
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'error', 'ok', '' );
        $dialog->set_markup( __
"None of the perl modules <b>Graphics::Magick</b> and <b>Image::Magick</b> are installed: AMC won't work properly!"
        );
        $dialog->run;
        $dialog->destroy;
    }
}

# tests if debian package auto-multiple-choice-common is installed but
# not auto-multiple-choice...

sub deb_is_installed {
    my ($package_name) = @_;
    my $v = '';
    open( QUERY, "-|", "dpkg-query", "-W", '--showformat=${Version}\n',
        $package_name );
    while (<QUERY>) {
        $v = $1 if (/^\s*([^\s]+)\s*$/);
    }
    close(QUERY);
    return ($v);
}

sub test_debian_amc {
    if ( commande_accessible("dpkg-query") ) {
        if ( deb_is_installed("auto-multiple-choice-common")
            && !deb_is_installed("auto-multiple-choice") )
        {
            debug "ERROR: auto-multiple-choice package not installed!";
            my $dialog =
              Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
                'error', 'ok', '' );
            $dialog->set_markup( __
"The package <i>auto-multiple-choice-common</i> is installed, but not <i>auto-multiple-choice</i>.\n<b>AMC won't work properly until you install auto-multiple-choice package!</b>"
            );
            $dialog->run;
            $dialog->destroy;
        }
    }
}

sub check_for_tmp_disk_space {
    my ($needs_mo) = @_;
    my $tmp_path   = tmpdir();
    my $space      = free_disk_mo($tmp_path);
    if ( defined($space) && $space < $needs_mo ) {
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'error', 'ok', '' );
        $dialog->set_markup(
            sprintf(
                (
                    __
"There is too little space left in the temporary disk directory (%s). <b>Please clean this directory and try again.</b>"
                ),
                $tmp_path
            )
        );
        $dialog->run;
        $dialog->destroy;
        return 0;
    }
    return 1;
}

# Warn if Notify is not available
sub test_libnotify {
    my $initted = eval { Notify::is_initted() };
    if ( !$initted ) {
        eval {
            Glib::Object::Introspection->setup(
                basename => 'Notify',
                version  => '0.7',
                package  => 'Notify'
            ) if ( !defined($initted) );

            # Set application name for notifications
            Notify::init('Auto Multiple Choice');
        };
        $libnotify_error = $@;

        if ( $libnotify_error && $config->get('notify_desktop') ) {
            debug "libnotify loading error: $libnotify_error";
            my $dialog =
              Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
                'warning', 'ok', '' );
            $dialog->set_markup( __
"Please install <b>libnotify</b> to make desktop notifications available."
            );
            $dialog->run;
            $dialog->destroy;
            $config->set( 'notify_desktop', '' );
        }
    }
}

# goes to a specific directory if the project directory is given as a
# command-line option

if ( -f $project_dir ) {
    $project_dir =~ s/\/?options\.xml$//;
}
$project_dir =~ s/\/+$//;

if ( -d $project_dir ) {
    debug "Opening project from directory $project_dir ...";
    $project_dir = Cwd::realpath($project_dir);
    my ( $v, $d, $f ) = splitpath($project_dir);
    my $r = catpath( $v, $d, '' );
    $r =~ s/\/+$//;
    $config->set( 'rep_projets', $r );
    @ARGV = $f;
}

# creates projets and models directories if needed (if not present,
# Edit/Parameters can be disrupted)

for my $k (qw/projects_home rep_modeles/) {
    my $path = $config->get_absolute($k);
    if ( -e $path ) {
        debug "WARNING: $path ($k) is not a directory!" if ( !-d $path );
    } else {
        mkdir($path);
    }
}

$config->set_projects_home( $config->get('rep_projets') );

#############################################################################

my %projet = ();

sub bon_encodage {
    my ($type) = @_;
    return ( $config->get("encodage_$type")
          || $config->get("defaut_encodage_$type")
          || "UTF-8" );
}

sub csv_build_0 {
    my ( $k, @default ) = @_;
    push @default, grep { $_ } map { s/^\s+//; s/\s+$//; $_; }
      split( /,+/, $config->get( 'csv_' . $k . '_headers' ) );
    return ( "(" . join( "|", @default ) . ")" );
}

sub csv_build_name {
    return (csv_build_0( 'surname', 'nom', 'surname' ) . ' '
          . csv_build_0( 'name', 'prenom', 'name' ) );
}

sub id2file {
    my ( $id, $prefix, $extension ) = (@_);
    $id =~ s/\+//g;
    $id =~ s/\//-/g;
    return ( $config->get_absolute('cr') . "/$prefix-$id.$extension" );
}

sub is_local {
    my ( $f, $proj ) = @_;
    my $prefix = $config->get('rep_projets') . "/";
    $prefix .= $projet{nom} . "/" if ($proj);
    if ( defined($f) ) {
        return ( $f !~ /^[\/%]/ || $f =~ /^$prefix/ || $f =~ /[\%]PROJET\// );
    } else {
        return ('');
    }
}

sub fich_options {
    my ( $nom, $rp ) = @_;

    $rp = $config->get('rep_projets') if ( !$rp );
    $rp .= "/$nom/options.xml";

    debug "Options file: " . show_utf8($rp);

    return ($rp);
}

sub moteur_latex {
    return ( $config->get('moteur_latex_b')
          || $config->get('defaut_moteur_latex_b') );
}

sub read_glade {
    my ( $main_widget, @widgets ) = @_;
    my $g          = Gtk3::Builder->new();
    my $glade_file = $glade_base . $main_widget . ".glade";
    debug "Reading glade file " . $glade_file;
    $g->set_translation_domain('auto-multiple-choice');
    $g->add_from_file($glade_file);
    for my $i ( $main_widget, @widgets ) {
        $w{$i} = $g->get_object($i);
        if ( ref( $w{$i} ) =~ /::(FileChooser|About)?Dialog$/
            && !$w{$i}->is_visible() )
        {
            debug "Found modal dialog: $i";
            $w{$i}->set_transient_for( $w{main_window} );
            $w{$i}->set_modal(1);
        }
        if ( $w{$i} ) {
            $w{$i}->set_name($i) if ( $i !~ /^(apropos)$/ );
        } else {
            debug_and_stderr
              "WARNING: Object $i not found in $main_widget glade file.";
        }
    }
    $g->connect_signals(undef);
    return ($g);
}

# As a workaround for Bug #93 these widgets are disabled when Preferences window is opened.
# Since Bug #93 only affects Ubuntu 12.04 LTS, this workaround can be safely removed when
# Ubuntu 12.04 LTS reaches its end of life date i.e. April 2017

my @widgets_disabled_when_preferences_opened = (qw/menu_popover/);

my @widgets_only_when_opened =
  (qw/cleanup_menu menu_projet_enreg menu_projet_modele/);

my $gui = read_glade(
    'main_window',
    qw/onglets_projet onglet_preparation
      documents_popover toggle_documents
      but_question but_solution but_indiv_solution but_catalog doc_line1
      prepare_docs prepare_layout prepare_src
      send_subject_config_button send_subject_action
      menu_popover header_bar
      state_layout state_layout_label
      state_docs state_docs_label
      state_unrecognized state_unrecognized_label
      state_marking state_marking_label state_assoc state_assoc_label
      state_overwritten state_overwritten_label
      button_edit_src
      button_unrecognized button_show_missing
      edition_latex
      onglet_notation onglet_saisie onglet_reports
      log_general commande avancement annulation button_mep_warnings
      liste_filename liste_edit liste_setfile liste_refresh
      menu_debug
      menu_columns
      toggle_column_updated toggle_column_mse toggle_column_sensitivity toggle_column_file
      diag_tree state_capture state_capture_label
      maj_bareme regroupement_corriges
      groupe_model
      pref_assoc_c_assoc_code pref_assoc_c_liste_key
      export_c_format_export
      export_c_export_sort export_cb_export_include_abs
      config_export_modules standard_export_options
      notation_c_regroupement_type notation_c_regroupement_compose
      pref_prep_s_nombre_copies pref_prep_c_filter
      /, @widgets_only_when_opened, @widgets_disabled_when_preferences_opened
);

# Grid lines are not well-positioned in RTL environments, I don't know
# why... so I remove them.
if ( $w{main_window}->get_direction() eq 'rtl' ) {
    debug "RTL mode: removing vertical grids";
    for (qw/documents diag inconnu/) {
        my $w = $gui->get_object( $_ . '_tree' );
        $w->set_grid_lines('horizontal') if ($w);
    }
}

$w{commande}->hide();

sub debug_set {
    $debug = $w{menu_debug}->get_active;
    debug "DEBUG MODE : OFF" if ( !$debug );
    set_debug_mode($debug);
    if ( $debug && !$do_nothing ) {
        debug "DEBUG MODE : ON";

        my $dialog = Gtk3::MessageDialog->new(
            $w{main_window},
            'destroy-with-parent',
            'info', 'ok',

            # TRANSLATORS: Message when switching to debugging mode.
            __("Debugging mode.") . " "

              . sprintf(
# TRANSLATORS: Message when switching to debugging mode. %s will be replaced with the path of the log file.
                __ "Debugging informations will be written in file %s.",
                AMC::Basic::debug_file()
              )
        );
        $dialog->run;
        $dialog->destroy;
    }
    Glib::Timeout->add( 500, sub { $w{menu_popover}->hide(); return (0); } );
}

$w{menu_debug}->set_active($debug);

sub open_menu {
    $w{menu_popover}->show_all();
}

# learning

my $learning =
  AMC::Gui::Learning->new( config => $config, main_window => $w{main_window} );

sub annule_apprentissage {
    $learning->forget();
}

# add doc list menu

my $docs_menu = Gtk3::Menu->new();

my @doc_langs = ();

my $hdocdir = amc_specdir('doc/auto-multiple-choice') . "/html/";
if ( opendir( DOD, $hdocdir ) ) {
    push @doc_langs,
      map  { s/auto-multiple-choice\.//; $_; }
      grep { /auto-multiple-choice\...(_..)?/ } readdir(DOD);
    closedir(DOD);
} else {
    debug("DOCUMENTATION : Can't open directory $hdocdir: $!");
}

my %ltext_loc = (
# TRANSLATORS: One of the documentation languages.
    French => __ "French",

    # TRANSLATORS: One of the documentation languages.
    English => __ "English",

    # TRANSLATORS: One of the documentation languages.
    Japanese => __ "Japanese",
);

### modele DIAGNOSTIQUE SAISIE

my $diag_store;

sub new_diagstore {
    $diag_store = Gtk3::ListStore->new(
        'Glib::String', 'Glib::String', 'Glib::String', 'Glib::String',
        'Glib::String', 'Glib::String', 'Glib::String', 'Glib::String',
        'Glib::String', 'Glib::String', 'Glib::String', 'Glib::String'
    );
    $diag_store->set_sort_func( DIAG_EQM,       \&sort_num,    DIAG_EQM );
    $diag_store->set_sort_func( DIAG_DELTA,     \&sort_num,    DIAG_DELTA );
    $diag_store->set_sort_func( DIAG_SCAN_FILE, \&sort_string, DIAG_SCAN_FILE );
    $diag_store->set_sort_func( DIAG_ID,
        \&sort_from_columns,
        [
            { type => 'n', col => DIAG_ID_STUDENT },
            { type => 'n', col => DIAG_ID_COPY },
            { type => 'n', col => DIAG_ID_PAGE },
        ]
    );
}

sub sort_diagstore {
    $diag_store->set_sort_column_id( DIAG_ID, 'ascending' );
}

sub show_diagstore {
    $w{diag_tree}->set_model($diag_store);
}

new_diagstore();
sort_diagstore();
show_diagstore();

my %capture_column = ();
my ( $renderer, $column );

$renderer = Gtk3::CellRendererText->new;

$column = Gtk3::TreeViewColumn->new_with_attributes(
# TRANSLATORS: This is the title of the column containing student/copy identifier in the table showing the results of data captures.
    __ "identifier",
    $renderer,
    text       => DIAG_ID,
    background => DIAG_ID_BACK
);
$column->set_sort_column_id(DIAG_ID);
$w{diag_tree}->append_column($column);

$renderer = Gtk3::CellRendererText->new;

$capture_column{updated} =
# TRANSLATORS: This is the title of the column containing data capture date/time in the table showing the results of data captures.
  Gtk3::TreeViewColumn->new_with_attributes( __ "updated", $renderer,
    text => DIAG_MAJ );
$capture_column{updated}->set_sort_column_id(DIAG_MAJ_NUM);
$w{diag_tree}->append_column( $capture_column{updated} );

$renderer = Gtk3::CellRendererText->new;

$capture_column{mse} = Gtk3::TreeViewColumn->new_with_attributes(
# TRANSLATORS: This is the title of the column containing Mean Square Error Distance (some kind of mean distance between the location of the four corner marks on the scan and the location where they should be if the scan was not distorted at all) in the table showing the results of data captures.
    __ "MSE",
    $renderer,
    text       => DIAG_EQM,
    background => DIAG_EQM_BACK
);
$capture_column{mse}->set_sort_column_id(DIAG_EQM);
$w{diag_tree}->append_column( $capture_column{mse} );

$renderer = Gtk3::CellRendererText->new;

$capture_column{sensitivity} = Gtk3::TreeViewColumn->new_with_attributes(
# TRANSLATORS: This is the title of the column containing so-called "sensitivity" (an indicator telling the user if the darkness ratio of some boxes on the page are very near the threshold. A great value tells that some darkness ratios are very near the threshold, so that the capture is very sensitive to the threshold. A small value is a good thing) in the table showing the results of data captures.
    __ "sensitivity",
    $renderer,
    text       => DIAG_DELTA,
    background => DIAG_DELTA_BACK
);
$capture_column{sensitivity}->set_sort_column_id(DIAG_DELTA);
$w{diag_tree}->append_column( $capture_column{sensitivity} );

$renderer = Gtk3::CellRendererText->new;
$capture_column{file} =
  Gtk3::TreeViewColumn->new_with_attributes( __ "scan file",
    $renderer, text => DIAG_SCAN_FILE );
$capture_column{file}->set_sort_column_id(DIAG_SCAN_FILE);
$w{diag_tree}->append_column( $capture_column{file} );

$w{diag_tree}->get_selection->set_mode('multiple');

# columns to be shown...

sub toggle_column {
    my ($item) = @_;
    if ( $item->get_name() =~ /toggle_column_(.*)/ ) {
        my $type    = $1;
        my $checked = $item->get_active();
        $capture_column{$type}->set_visible($checked);
    } else {
        debug "ERROR: unknown toggle_column name: " . $item->get_name();
    }
}

# Columns that should be hidden at startup:

for my $c (qw/updated file/) {
    $w{ "toggle_column_" . $c }->set_active(0);
}

my $cb_model_vide_key =
# TRANSLATORS: you can omit the [...] part, just here to explain context
  cb_model( '' => __p "(none) [No primary key found in association list]" );

my $cb_model_vide_code =
# TRANSLATORS: you can omit the [...] part, just here to explain context
  cb_model( '' => __p "(none) [No code found in LaTeX file]" );

$prefs->store_register(

    liste_key     => $cb_model_vide_key,
    assoc_code    => $cb_model_vide_code,
    format_export => cb_model(
        map { $_ => "AMC::Export::register::$_"->name() } (@export_modules)
    ),
    filter => cb_model(
        map { $_ => "AMC::Filter::register::$_"->name() } (@filter_modules)
    ),

    after_export => cb_model(
# TRANSLATORS: One of the actions that can be done after exporting the marks. Here, do nothing more. This is a menu entry.
        "" => __ "that's all",

# TRANSLATORS: One of the actions that can be done after exporting the marks. Here, open the exported file. This is a menu entry.
        file => __ "open the file",

# TRANSLATORS: One of the actions that can be done after exporting the marks. Here, open the directory where the file is. This is a menu entry.
        dir => __ "open the directory",
    ),

    export_sort => cb_model(
# TRANSLATORS: One of the possible sorting criteria for students in the exported spreadsheet with scores: the student name. This is a menu entry.
        n => __ "name",

# TRANSLATORS: One of the possible sorting criteria for students in the exported spreadsheet with scores: the student sheet number. This is a menu entry.
        i => __ "exam copy number",

# TRANSLATORS: One of the possible sorting criteria for students in the exported spreadsheet with scores: the line where one can find this student in the students list file. This is a menu entry.
        l => __ "line in students list",

# TRANSLATORS: you can omit the [...] part, just here to explain context
# One of the possible sorting criteria for students in the exported spreadsheet with scores: the student mark. This is a menu entry.
        m => __p("mark [student mark, for sorting]"),
    ),

    regroupement_type => cb_model(
# TRANSLATORS: One of the possible way to group annotated answer sheets together to PDF files: make one PDF file per student, with all his pages. This is a menu entry.
        STUDENTS => __ "One file per student",

# TRANSLATORS: One of the possible way to group annotated answer sheets together to PDF files: make only one PDF with all students sheets. This is a menu entry.
        ALL => __ "One file for all students",
    ),

    regroupement_compose => cb_model(
# TRANSLATORS: One of the possible way to annotate answer sheets: here we only select pages where the student has written something (in separate answer sheet mode, these are the pages from the answer sheet and not the pages from the subject).
        0 => __ "Only pages with answers",

# TRANSLATORS: One of the possible way to annotate answer sheets: here we take the pages were the students has nothing to write (often question pages from a subject with separate answer sheet option) from the subject.
        1 => __ "Question pages from subject",

# TRANSLATORS: One of the possible way to annotate answer sheets: here we take the pages were the students has nothing to write (often question pages from a subject with separate answer sheet option) from the correction.
        2 => __ "Question pages from correction",
    ),

# TRANLATORS: For which students do you want to annotate papers? This is a menu entry.
    regroupement_copies => cb_model(
        ALL => __ "All students",

# TRANLATORS: For which students do you want to annotate papers? This is a menu entry.
        SELECTED => __ "Selected students",
    ),

);

# Add config GUI for export modules...

for my $m (@export_modules) {
    my $x = "AMC::Export::register::$m"->build_config_gui( \%w, $prefs );
    if ($x) {
        $w{ 'config_export_module_' . $m } = $x;
        $w{config_export_modules}->pack_start( $x, 0, 0, 0 );
    }
}

### export

sub maj_export {
    my $old_format = $config->get('format_export');

    $prefs->valide_options_for_domain( 'export', '', @_ );

    if ( $config->key_changed("export_sort") ) {
        annotate_source_change( $projet{_capture}, 1 );
    }

    debug "Format : " . $config->get('format_export');

    for (@export_modules) {
        if ( $w{ 'config_export_module_' . $_ } ) {
            if ( $config->get('format_export') eq $_ ) {
                $w{ 'config_export_module_' . $_ }->show;
            } else {
                $w{ 'config_export_module_' . $_ }->hide;
            }
        }
    }

    my %hide =
      ( "AMC::Export::register::" . $config->get('format_export') )->hide();
    for (qw/standard_export_options/) {
        if ( $hide{$_} ) {
            $w{$_}->hide();
        } else {
            $w{$_}->show();
        }
    }
}

sub exporte {

    maj_export();

    my $format  = $config->get('format_export');
    my @options = ();
    my $ext     = "AMC::Export::register::$format"->extension();
    if ( !$ext ) {
        $ext = lc($format);
    }
    my $type = "AMC::Export::register::$format"->type();
    my $code = $config->get('code_examen');
    $code = $projet{nom} if ( !$code );

    my $output       = $shortcuts->absolu( '%PROJET/exports/' . $code . $ext );
    my @needs_module = ();

    my %ofc = "AMC::Export::register::$format"->options_from_config($config);
    my $needs_catalog =
      "AMC::Export::register::$format"->needs_catalog($config);
    for ( keys %ofc ) {
        push @options, "--option-out", $_ . '=' . $ofc{$_};
    }
    push @needs_module, "AMC::Export::register::$format"->needs_module();

    if (@needs_module) {

        # teste si les modules necessaires sont disponibles

        my @manque = ();

        for my $m (@needs_module) {
            if ( !check_install( module => $m ) ) {
                push @manque, $m;
            }
        }

        if (@manque) {
            debug 'Exporting to '
              . $format
              . ': Needs perl modules '
              . join( ', ', @manque );

            my $dialog = Gtk3::MessageDialog->new(
                $w{main_window},
                'destroy-with-parent',
                'error', 'ok',
                __(
"Exporting to '%s' needs some perl modules that are not installed: %s. Please install these modules or switch to another export format."
                ),
                "AMC::Export::register::$format"->name(),
                join( ', ', @manque )
            );
            $dialog->run;
            $dialog->destroy;

            return ();
        }
    }

    # If some data involving detailed results (concerning some
    # particular answers) is required, then check that the catalog
    # document is prepared, or propose to build it.  This way, answers
    # will be identified by the character drawn in the boxes in the
    # catalog document. These characters default to A, B, C and so on,
    # but can be others if requested in the source file.

    if ($needs_catalog) {
        if ( !$projet{_layout}->nb_chars_transaction() ) {
            my $dialog =
              Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
                'question', 'yes-no', '' );
            $dialog->set_markup( __
"When referring to a particular answer in the export, the letter used will be the one found in the catalog. However, the catalog has not yet been built. Do you want to build it now?"
            );
            $dialog->get_widget_for_response('yes')->get_style_context()
              ->add_class("suggested-action");
            my $reponse = $dialog->run;
            $dialog->destroy;
            if ( $reponse eq 'yes' ) {
                update_catalog();
            }
        }
    }

    # wait for GUI update before going on with the table
    Glib::Idle->add(
        \&export_go,
        {
            format => $format,
            output => $output,
            o      => \@options,
            type   => $type,
        },
        Glib::G_PRIORITY_LOW
    );
}

sub export_go {
    my ($opts) = @_;
    commande(
        commande => [
            "auto-multiple-choice",
            "export",
            "--debug",
            debug_file(),
            pack_args(
                "--module",
                $opts->{format},
                "--data",
                $config->get_absolute('data'),
                "--useall",
                $config->get('export_include_abs'),
                "--sort",
                $config->get('export_sort'),
                "--fich-noms",
                $config->get_absolute('listeetudiants'),
                "--noms-encodage",
                bon_encodage('liste'),
                "--csv-build-name",
                csv_build_name(),
                ( $config->get('annote_rtl') ? "--rtl" : "--no-rtl" ),
                "--output",
                $opts->{output},
                @{ $opts->{o} },
            ),
        ],
        texte           => __ "Exporting marks...",
        'progres.id'    => 'export',
        'progres.pulse' => 0.01,
        fin             => \&export_done,
        o               => $opts,
    );
}

sub export_done {
    my ( $c, %data ) = @_;
    my $output = $c->{o}->{output};
    my $type   = $c->{o}->{type};
    if ( -f $output ) {

        # shows export messages

        my $t = $c->higher_message_type();
        if ($t) {
            my $dialog = Gtk3::MessageDialog->new(
                $w{main_window},
                'destroy-with-parent',
                ( $t eq 'ERR' ? 'error' : $t eq 'WARN' ? 'warning' : 'info' ),
                'ok',
                join( "\n", $c->get_messages($t) )
            );
            $dialog->run;
            $dialog->destroy;
        }

        if ( $config->get('after_export') eq 'file' ) {
            my $cmd = commande_accessible(
                [
                    $config->get( $type . '_viewer' ),
                    $config->get( $type . '_editor' ),
                    'xdg-open',
                    'open'
                ]
            );
            commande_parallele( $cmd, $output ) if ($cmd);
        } elsif ( $config->get('after_export') eq 'dir' ) {
            view_dir( $shortcuts->absolu('%PROJET/exports/') );
        }
    } else {
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'warning', 'ok',
            __ "Export to %s did not work: file not created...", $output );
        $dialog->run;
        $dialog->destroy;
    }
}

## menu contextuel sur liste diagnostique -> visualisation zoom/page

my %diag_menu = (
# TRANSLATORS: One of the popup menu that appears when right-clicking on a page in the data capture diagnosis table. Choosing this entry, an image will be opened to see where the corner marks were detected.
    page => { text => __ "page adjustment", icon => 'gtk-zoom-fit' },

# TRANSLATORS: One of the popup menu that appears when right-clicking on a page in the data capture diagnosis table. Choosing this entry, a window will be opened were the user can see all boxes on the scans and how they were filled by the students, and correct detection of ticked-or-not if needed.
    zoom => { text => __ "boxes zooms", icon => 'gtk-zoom-in' },
);

sub zooms_display {
    my ( $student, $page, $copy, $forget_it ) = @_;

    debug "Zooms view for " . pageids_string( $student, $page, $copy ) . "...";
    my $zd = $shortcuts->absolu('%PROJET/cr/zooms');
    debug "Zooms directory $zd";
    if (   $w{zooms_window}
        && $w{zooms_window}->actif )
    {
        $w{zooms_window}->page( [ $student, $page, $copy ], $zd, $forget_it );
    } elsif ( !$forget_it ) {
        $w{zooms_window} = AMC::Gui::Zooms::new(
            seuil     => $config->get('seuil'),
            seuil_up  => $config->get('seuil_up'),
            n_cols    => $config->get('zooms_ncols'),
            zooms_dir => $zd,
            page_id   => [ $student, $page, $copy ],
            'size-prefs', $config,
            encodage_interne => $config->get('encodage_interne'),
            data             => $projet{_capture},
            'cr-dir'         => $config->get_absolute('cr'),
            list_view        => $w{diag_tree},
            global_options   => $config,
            prefs            => $prefs,
        );
    }
}

sub zooms_line_base {
    my ($forget_it)    = @_;
    my @selected       = $w{diag_tree}->get_selection->get_selected_rows;
    my $first_selected = $selected[0]->[0];
    if ( defined($first_selected) ) {
        my $iter = $diag_store->get_iter($first_selected);
        my $id   = $diag_store->get( $iter, DIAG_ID );
        zooms_display(
            (
                map { $diag_store->get( $iter, $_ ) }
                  ( DIAG_ID_STUDENT, DIAG_ID_PAGE, DIAG_ID_COPY )
            ),
            $forget_it
        );
    }
}

sub zooms_line      { zooms_line_base(1); }
sub zooms_line_open { zooms_line_base(0); }

sub layout_line {
    my @selected = $w{diag_tree}->get_selection->get_selected_rows;
    for my $s ( @{ $selected[0] } ) {
        my $iter = $diag_store->get_iter($s);
        my @id   = map { $diag_store->get( $iter, $_ ); }
          ( DIAG_ID_STUDENT, DIAG_ID_PAGE, DIAG_ID_COPY );
        $projet{_capture}->begin_read_transaction('Layl');
        my $f = $config->get_absolute('cr') . '/'
          . $projet{_capture}->get_layout_image(@id);
        $projet{_capture}->end_transaction('Layl');

        commande_parallele( $config->get('img_viewer'), $f ) if ( -f $f );
    }
}

sub delete_line {
    my @selected = $w{diag_tree}->get_selection->get_selected_rows;
    my $f;
    if ( @{ $selected[0] } ) {
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'question', 'yes-no', '' );
        $dialog->set_markup(
            sprintf(
                (
                    __
"You requested to delete all data capture results for %d page(s)"
                ),
                1 + $#{ $selected[0] }
              )
              . "\n" . '<b>'
              . (
                __
"All data and image files related to these pages will be deleted."
              )
              . "</b>\n"
              . ( __ "Do you really want to continue?" )
        );
        $dialog->get_widget_for_response('yes')->get_style_context()
          ->add_class("destructive-action");
        my $reponse = $dialog->run;
        $dialog->destroy;
        if ( $reponse eq 'yes' ) {
            my @iters = ();
            $projet{_capture}->begin_transaction('rmAN');
            for my $s ( @{ $selected[0] } ) {
                my $iter = $diag_store->get_iter($s);
                my @id   = map { $diag_store->get( $iter, $_ ); }
                  ( DIAG_ID_STUDENT, DIAG_ID_PAGE, DIAG_ID_COPY );
                debug "Removing data capture for " . pageids_string(@id);
                #
                # 1) get image files generated, and remove them
                #
                my $crdir = $config->get_absolute('cr');
                my @files = ();
                #
                # scan file
                push @files,
                  $shortcuts->absolu( $projet{_capture}->get_scan_page(@id) );
                #
                # layout image, in cr directory
                push @files,
                  $crdir . '/' . $projet{_capture}->get_layout_image(@id);
                #
                # annotated scan
                if(my $a=$projet{_capture}->get_annotated_page(@id)) {
                  push @files,
                    $crdir
                    . '/corrections/jpg/'
                    . $a;
                }
                #
                # zooms
                push @files,
                  map { $crdir . '/zooms/' . $_ } grep { defined($_) }
                  ( $projet{_capture}->get_zones_images( @id, ZONE_BOX ) );
                #
                for (@files) {
                    if ( -f $_ ) {
                        debug "Removing $_";
                        unlink($_);
                    }
                }
                #
                # 2) remove data from database
                #
                $projet{_capture}->delete_page_data(@id);

                if ( $config->get('auto_capture_mode') == 1 ) {
                    $projet{_scoring}->delete_scoring_data( @id[ 0, 2 ] );
                    $projet{_association}
                      ->delete_association_data( @id[ 0, 2 ] );
                }

                push @iters, $iter;
            }

            for (@iters) { $diag_store->remove($_); }
            update_analysis_summary();
            $projet{_capture}->end_transaction('rmAN');

            assoc_state();
        }
    }
}

$w{diag_tree}->signal_connect(
    button_release_event => sub {
        my ( $self, $event ) = @_;
        return 0 unless $event->button == 3;
        my ( $path, $column, $cell_x, $cell_y ) =
          $w{diag_tree}->get_path_at_pos( $event->x, $event->y );
        if ($path) {
            my $iter = $diag_store->get_iter($path);
            my $id   = [ map { $diag_store->get( $iter, $_ ) }
                  ( DIAG_ID_STUDENT, DIAG_ID_PAGE, DIAG_ID_COPY ) ];

            my $menu    = Gtk3::Menu->new;
            my $c       = 0;
            my @actions = ('page');

            # new zooms viewer

            $projet{_capture}->begin_read_transaction('ZnIm');
            my @bi =
              grep { -f $shortcuts->absolu('%PROJET/cr/zooms') . "/" . $_ }
              $projet{_capture}->zone_images( $id->[0], $id->[2], ZONE_BOX );
            $projet{_capture}->end_transaction('ZnIm');

            if (@bi) {
                $c++;
                my $item = Gtk3::ImageMenuItem->new( $diag_menu{zoom}->{text} );
                $item->set_image(
                    Gtk3::Image->new_from_icon_name(
                        $diag_menu{zoom}->{icon}, 'menu'
                    )
                );
                $menu->append($item);
                $item->show;
                $item->signal_connect(
                    activate => sub {
                        my ( undef, $sortkey ) = @_;
                        zooms_display(@$id);
                    },
                    $_
                );
            } else {
                push @actions, 'zoom';
            }

            # page viewer and old zooms viewer

            foreach $a (@actions) {
                my $f;
                if ( $a eq 'page' ) {
                    $projet{_capture}->begin_read_transaction('gLIm');
                    $f = $config->get_absolute('cr') . '/'
                      . $projet{_capture}->get_layout_image(@$id);
                    $projet{_capture}->end_transaction('gLIm');
                } else {
                    $f = id2file( $id, $a, 'jpg' );
                }
                if ( -f $f ) {
                    $c++;
                    my $item =
                      Gtk3::ImageMenuItem->new( $diag_menu{$a}->{text} );
                    $item->set_image(
                        Gtk3::Image->new_from_icon_name(
                            $diag_menu{$a}->{icon}, 'menu'
                        )
                    );
                    $menu->append($item);
                    $item->show;
                    $item->signal_connect(
                        activate => sub {
                            my ( undef, $sortkey ) = @_;
                            debug "Looking at $f...";
                            commande_parallele( $config->get('img_viewer'),
                                $f );
                        },
                        $_
                    );
                }
            }
            $menu->popup( undef, undef, undef, undef,
                $event->button, $event->time )
              if ( $c > 0 );
            return 1;    # stop propagation!

        }
    }
);

### Appel a des commandes externes -- log, annulation

my %les_commandes = ();
my $cmd_id        = 0;

sub commande {
    my (@opts) = @_;
    $cmd_id++;

    my $c = AMC::Gui::Commande::new(
        avancement => $w{avancement},
        log        => $w{log_general},
        finw       => sub {
            my $c = shift;
            $w{onglets_projet}->set_sensitive(1);
            $w{commande}->hide();
            delete $les_commandes{ $c->{_cmdid} };
        },
        @opts
    );

    $c->{_cmdid} = $cmd_id;
    $les_commandes{$cmd_id} = $c;

    $w{onglets_projet}->set_sensitive(0);
    $w{commande}->show();

    $c->open();
}

sub commande_annule {
    for ( keys %les_commandes ) { $les_commandes{$_}->quitte(); }
}

sub commande_parallele {
    my (@c) = (@_);
    if ( commande_accessible( $c[0] ) ) {
        my $pid = fork();
        if ( $pid == 0 ) {
            debug "Command // [$$] : " . join( " ", @c );
            exec(@c)
              || debug "Exec $$ : error";
            exit(0);
        }
    } else {
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'error', 'ok', '' );
        $dialog->set_markup(
            sprintf(
                __
"Following command could not be run: <b>%s</b>, perhaps due to a poor configuration?",
                $c[0]
            )
        );
        $dialog->run;
        $dialog->destroy;

    }
}

### Actions des menus

my $proj_store;

sub projet_nouveau {
    AMC::Gui::ProjectManager->new(
        parent_window => $w{main_window},
        config        => $config,
        action        => 'new',
        new_callback  => \&create_new_project
    );
}

sub projet_charge {
    AMC::Gui::ProjectManager->new(
        parent_window => $w{main_window},
        config        => $config,
        action        => 'open',
        open_callback => \&open_project
    );
}

sub projet_gestion {
    AMC::Gui::ProjectManager->new(
        parent_window   => $w{main_window},
        config          => $config,
        action          => 'manage',
        current_project => $projet{nom},
        progress_widget => $w{avancement},
        command_widget  => $w{commande}
    );
}

sub open_project {
    my ( $dir, $project ) = @_;

    my $reponse      = 'yes';
    my $options_file = fich_options( $project, $dir );
    if ( !-f $options_file ) {
        debug_and_stderr "Options file not found: " . show_utf8($options_file);
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'warning', 'yes-no', '' );
        $dialog->set_markup(
            sprintf(
                __("You selected directory <b>%s</b> as a project to open.")
                  . " "
                  . __(
"However, this directory does not seem to contain a project. Do you still want to try?"
                  ),
                $project
            )
        );
        $reponse = $dialog->run;
        $dialog->destroy;
    }
    if ( $reponse eq 'yes' ) {
        quitte_projet() or return ();

        # If the project to open lies on a removable media, suggest
        # to copy it first to the user standard projects directory:

        if (   $dir =~ /^\/media\//
            && $config->get_absolute('projects_home') !~ /^\/media\// )
        {
            my $dialog = Gtk3::MessageDialog->new( $w{main_window},
                'destroy-with-parent', 'warning', 'yes-no', '' );
            $dialog->set_markup(
                sprintf(
                    __(
"You selected project <b>%s</b> from directory <i>%s</i>."
                      )
                      . " "
                      . __(
"Do you want to copy this project to your projects directory before opening it?"
                      ),
                    $project, $dir
                )
            );
            my $r = $dialog->run;
            $dialog->destroy;
            if ( $r eq 'yes' ) {
                my $proj_dest = new_filename(
                    $config->get_absolute('projects_home') . '/' . $project );
                if ( project_copy( $dir . '/' . $project, $proj_dest ) ) {
                    ( undef, undef, $proj_dest ) = splitpath($proj_dest);
                    $dir     = $config->get_absolute('projects_home');
                    $project = $proj_dest;
                }
            }
        }

        # OK, now, open the project!

        $config->set_projects_home($dir);
        projet_ouvre($project);
    }
}

sub create_new_project {
    my ( $dir, $project ) = @_;

    quitte_projet() or return ();

    $config->set_projects_home($dir);
    if ( projet_ouvre( $project, 1 ) ) {
        projet_sauve();
    }
}

sub projet_sauve {
    debug "Saving project...";

    $config->save();
}

sub projet_check_and_save {
    if ( $projet{nom} ) {
        valide_options_notation();
        $config->save();
    }
}

### Actions des boutons de la partie DOCUMENTS

sub format_markup {
    my ($t) = @_;
    $t =~ s/\&/\&amp;/g;
    return ($t);
}

sub mini { ( $_[0] < $_[1] ? $_[0] : $_[1] ) }

my %component_name = (
    latex_packages => __("LaTeX packages:"),
    commands       => __("Commands:"),
    fonts          => __("Fonts:"),
);

sub check_sty_version {
    my ($c) = @_;
    my $sty_v = $c->variable('styversion');
    $sty_v = '' if ( !defined($sty_v) );
    my $sty_p = $c->variable('stypath');
    my $amc_v = '@/PACKAGE_V_STY/@';
    if ( ( $sty_p || $sty_v ) && $sty_v ne $amc_v ) {
        $sty_v = 'unknown' if ( !$sty_v );
        $sty_p = 'unknown' if ( !$sty_p );
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'warning', 'ok', '' );
        $dialog->set_markup(
            __("Your AMC version and LaTeX style file version differ. Even if the documents are properly generated, this can lead to many problems using AMC.")
              . "\n"
              . __("<b>Please check your installation to get matching AMC and LaTeX style file versions.</b>")
              . "\n"
              . sprintf(
                __("AMC version: %s\nsty version: %s\nsty path: %s"),
                $amc_v, $sty_v, $sty_p
              )
        );
        $dialog->run;
        $dialog->destroy;
    }
}

sub update_document {
    my ( $mode, %opts ) = @_;

    commande(
        commande => [
            "auto-multiple-choice",
            "prepare",
            "--debug",
            debug_file(),
            pack_args(
                "--with",
                moteur_latex(),
                "--filter",
                $config->get('filter'),
                "--filtered-source",
                $config->get_absolute('filtered_source'),
                "--out-sujet",
                $config->get_absolute('doc_question'),
                "--out-corrige",
                $config->get_absolute('doc_solution'),
                "--out-corrige-indiv",
                $config->get_absolute('doc_indiv_solution'),
                "--out-catalog",
                $config->get_absolute('doc_catalog'),
                "--out-calage",
                $config->get_absolute('doc_setting'),
                "--mode",
                $mode,
                "--n-copies",
                $config->get('nombre_copies'),
                $config->get_absolute('texsrc'),
                "--prefix",
                $shortcuts->absolu('%PROJET/'),
                "--latex-stdout",
                "--data",
                $config->get_absolute('data'),
            )
        ],
        signal          => 2,
        texte           => __ "Documents update...",
        'progres.id'    => 'MAJ',
        'progres.pulse' => 0.01,
        fin             => \&end_of_document_update,
        o               => \%opts
    );
}

sub end_of_document_update {
    my ( $c, %data ) = @_;

    detecte_documents();

    if ( $data{cancelled} ) {
        debug "Prepare documents: CANCELLED!";
        return ();
    }

    check_sty_version($c);

    my @err  = $c->erreurs();
    my @warn = $c->warnings();
    if ( @err || @warn ) {
        debug "Errors preparing documents!";
        notify_end_of_work( 'documents',
            __ "Problems while preparing documents" );

        my $message = __("Problems while processing the source file.");
        if ( !$c->{o}->{partial} ) {
            $message .= " "
              . __(
"You have to correct the source file and re-run documents update."
              );
        }

        if (@err) {
            $message .= "\n\n"
              . __("<b>Errors</b>") . "\n"
              . join( "\n",
                map { format_markup($_) } ( @err[ 0 .. mini( 9, $#err ) ] ) )
              . ( $#err > 9
                ? "\n\n<i>(" . __("Only first ten errors written") . ")</i>"
                : "" );
        }
        if (@warn) {
            $message .= "\n\n"
              . __("<b>Warnings</b>") . "\n"
              . join( "\n",
                map { format_markup($_) } ( @warn[ 0 .. mini( 9, $#warn ) ] ) )
              . ( $#warn > 9
                ? "\n\n<i>(" . __("Only first ten warnings written") . ")</i>"
                : "" );
        }

        $message .= "\n\n" .

          sprintf(
# TRANSLATORS: Here, %s will be replaced with the translation of "Command output details", and refers to the small expandable part at the bottom of AMC main window, where one can see the output of the commands lauched by AMC.
            __("See also the processing log in '%s' below."),

# TRANSLATORS: Title of the small expandable part at the bottom of AMC main window, where one can see the output of the commands lauched by AMC.
            __ "Command output details"
          );
        $message .=
          " " . __("Use LaTeX editor or latex command for a precise diagnosis.")
          if ( $config->get('filter') eq 'latex' );

        debug($message);
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'error', 'ok', '' );
        $dialog->set_markup($message);
        $dialog->run;
        $dialog->destroy;

        return ();
    }

    notify_end_of_work( 'documents', __ "Documents have been prepared" );

    if ( $c->{o}->{partial} ) {
        debug "Partial: return";
        return ();
    }

    # verif que tout y est

    my $ok = 1;
    for (qw/question setting/) {
        $ok = 0 if ( !-f $config->get_absolute( 'doc_' . $_ ) );
    }
    if ($ok) {

        debug "All documents are successfully generated";

        # set project option from filter requests

        my %vars = $c->variables;
        for my $k ( keys %vars ) {
            if ( $k =~ /^project:(.*)/ ) {
                my $kk = $1;
                debug "Configuration: $k = $vars{$k}";
                $config->set( $k, $vars{$k} );
                $prefs->transmet_pref(
                    $gui,
                    prefix => 'pref_prep',
                    keys   => [$kk]
                );
            }
        }

        # success message

        $learning->lesson('MAJ_DOCS_OK');

        # Try to guess the best place to write question
        # scores when annotating. This option can be
        # changed later in the Edit/Preferences window.
        my $ap = 'marges';
        if ( $c->variable('scorezones') ) {
            $ap = 'zones';
        } elsif ( $c->variable('ensemble') ) {
            $ap = 'cases';
        }
        $config->set( 'annote_position', $ap );

        my $ensemble = $c->variable('ensemble') && !$c->variable('outsidebox');
        if ( ( $ensemble || $c->variable('insidebox') )
            && $config->get('seuil') < 0.4 )
        {
            my $dialog =
              Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
                'question', 'yes-no', '' );
            $dialog->set_markup(
                sprintf(
                    (
                        $ensemble
                        ? __("Your question has a separate answers sheet.")
                          . " "
                          . __("In this case, letters are shown inside boxes.")
                        : __(
"Your question is set to present labels inside the boxes to be ticked."
                        )
                    )
                    . " "

# TRANSLATORS: Here, %s will be replaced with the translation of "darkness threshold".
                      . __(
"For better ticking detection, ask students to fill out completely boxes, and choose parameter \"%s\" around 0.5 for this project."
                      )
                      . " "
                      . __("At the moment, this parameter is set to %.02f.")
                      . " "
                      . __("Would you like to set it to 0.5?")

                    ,
# TRANSLATORS: This parameter is the ratio of dark pixels number over total pixels number inside box above which a box is considered to be ticked.
                    __ "darkness threshold",
                    $config->get('seuil')
                )
            );
            my $reponse = $dialog->run;
            $dialog->destroy;
            if ( $reponse eq 'yes' ) {
                $config->set( 'seuil',    0.5 );
                $config->set( 'seuil_up', 1.0 );
            }
        }
    }

}

sub doc_maj {
    my $sur = 0;
    if ( $projet{_capture}->n_pages_transaction() > 0 ) {
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'warning', 'ok-cancel', '' );
        $dialog->set_markup(
            __(
"Papers analysis was already made on the basis of the current working documents."
              )
              . " "
              . __(
"You already made the examination on the basis of these documents."
              )
              . " "
              . __(
"If you modify working documents, you will not be capable any more of analyzing the papers you have already distributed!"
              )
              . " "
              . __("Do you wish to continue?") . " "
              . __(
"Click on OK to erase the former layouts and update working documents, or on Cancel to cancel this operation."
              )
              . " " . "<b>"
              . __("To allow the use of an already printed question, cancel!")
              . "</b>"
        );
        $dialog->get_widget_for_response('ok')->get_style_context()
          ->add_class("destructive-action");
        my $reponse = $dialog->run;
        $dialog->destroy;

        if ( $reponse ne 'ok' ) {
            return (0);
        }

        $sur = 1;
    }

    # deja des MEP fabriquees ?
    $projet{_layout}->begin_transaction('DMAJ');
    my $pc = $projet{_layout}->pages_count;
    $projet{_layout}->end_transaction('DMAJ');
    if ( $pc > 0 ) {
        if ( !$sur ) {
            my $dialog =
              Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
                'question', 'ok-cancel', '' );
            $dialog->set_markup(
                __("Layouts are already calculated for the current documents.")
                  . " "
                  . __(
"Updating working documents, the layouts will become obsolete and will thus be erased."
                  )
                  . " "
                  . __("Do you wish to continue?") . " "
                  . __(
"Click on OK to erase the former layouts and update working documents, or on Cancel to cancel this operation."
                  )
                  . " <b>"
                  . __(
                    "To allow the use of an already printed question, cancel!")
                  . "</b>"
            );
            $dialog->get_widget_for_response('ok')->get_style_context()
              ->add_class("destructive-action");
            my $reponse = $dialog->run;
            $dialog->destroy;

            if ( $reponse ne 'ok' ) {
                return (0);
            }
        }

        clear_processing('mep:');
    }

    # new layout document : XY (from LaTeX)

    if ( $config->get('doc_setting') =~ /\.pdf$/ ) {
        $config->set_project_option_to_default( 'doc_setting', 'FORCE' );
    }

    # check for filter dependencies

    my $filter_register =
      ( "AMC::Filter::register::" . $config->get('filter') )->new();

    my $check = $filter_register->check_dependencies();

    if ( !$check->{ok} ) {
        my $message = sprintf(
            __(
"To handle properly <i>%s</i> files, AMC needs the following components, that are currently missing:"
            ),
            $filter_register->name()
        ) . "\n";
        for my $k (qw/latex_packages commands fonts/) {
            if ( @{ $check->{$k} } ) {
                $message .= "<b>" . $component_name{$k} . "</b> ";
                if ( $k eq 'fonts' ) {
                    $message .=
                      join( ', ', map { @{ $_->{family} } } @{ $check->{$k} } );
                } else {
                    $message .= join( ', ', @{ $check->{$k} } );
                }
                $message .= "\n";
            }
        }
        $message .=
          __("Install these components on your system and try again.");

        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'error', 'ok', '' );
        $dialog->set_markup($message);
        $dialog->run;
        $dialog->destroy;

        return (0);
    }

    # set options from filter:

    if ( $config->get('filter') ) {
        $filter_register->set_oo($config);
        $filter_register->configure();
    }

    # remove pre-existing DOC-corrected.pdf (built by AMC-annotate)
    my $pdf_corrected = $shortcuts->absolu("DOC-corrected.pdf");
    if ( -f $pdf_corrected ) {
        debug "Removing pre-existing $pdf_corrected";
        unlink($pdf_corrected);
    }

    #
    my $mode_s = 's[';
    $mode_s .= 's' if ( $config->get('prepare_solution') );
    $mode_s .= 'c' if ( $config->get('prepare_catalog') );
    $mode_s .= ']';
    $mode_s .= 'k' if ( $config->get('prepare_indiv_solution') );

    update_document($mode_s);
}

sub filter_details {

    AMC::Gui::FilterDetails->new(
        parent_window => $w{main_window},
        config        => $config,
        main_gui      => $gui,
        main_prefs    => $prefs,
    );

}

my $cups;
my $g_imprime;

sub nonnul {
    my $s = shift;
    $s =~ s/\000//g;
    return ($s);
}

sub project_printing_method {
    if ( $config->get('project:pdfform') ) {
        return ('file');
    } else {
        return ( $config->get("methode_impression") );
    }
}

sub project_extract_with {
    my $conf = $config->get('print_extract_with');
    if ( $config->get('project:pdfform') ) {
        if ( $conf =~ /^(qpdf|sejda|pdftk\+NA)/ ) {
            return ($conf);
        } else {
            if ( commande_accessible('sejda-console') ) {
                return ('sejda-console');
            } elsif ( commande_accessible('qpdf') ) {
                return ('qpdf');
            } else {
                return ('pdftk+NA');
            }
        }
    } else {
        return ($conf);
    }
}

sub sujet_impressions {

    my $g = AMC::Gui::Printing->new(
        config         => $config,
        parent_window  => $w{main_window},
        layout         => $projet{_layout},
        print_callback => \&print_exams,
    );

    if ( $g->{preassoc} ) {
        valide_liste(
            nolabel => 1,
            gui     => $g->{main},
            prefix  => 'impfpu',
            key     => 'pdf_password_key',
        );
    }

}

sub print_exams {
    my ($options) = @_;

    return () if ( !@{$options->{exams}} );

    my $fh = File::Temp->new(
        TEMPLATE => "nums-XXXXXX",
        TMPDIR   => 1,
        UNLINK   => 1
    );
    print $fh join( "\n", @{$options->{exams}} ) . "\n";
    $fh->seek( 0, SEEK_END );

    my @o_answer = ( '--no-split', '--no-answer-first' );
    if ( $config->get('options_impression/print_answersheet') eq 'split' ) {
        @o_answer = ( '--split', '--no-answer-first' );
    } elsif ( $config->get('options_impression/print_answersheet') eq 'first' )
    {
        @o_answer = ( '--answer-first', '--no-split' );
    }

    my $extract_with = project_extract_with();

    my $directory = $config->get_absolute('options_impression/repertoire');
    debug "Directory: " . show_utf8($directory);
    my $prefix = __p("sheet [filename prefix when printing to files]");
    if ( $config->get('code_examen') ) {
        $prefix = $config->get('code_examen');
    }
    debug "Prefix: " . show_utf8($prefix);

    commande(
        commande => [
            "auto-multiple-choice",
            "imprime",
            "--debug",
            debug_file(),
            pack_args(
                "--methode",
                $options->{printing_method},
                "--imprimante",
                $config->get('imprimante'),
                "--options",
                $options->{options_string},
                "--output",
                "$directory/$prefix-%e.pdf",
                @o_answer,
                "--print-command",
                $config->get('print_command_pdf'),
                "--sujet",
                $config->get_absolute('doc_question'),
                "--data",
                $config->get_absolute('data'),
                "--progression-id",
                'impression',
                "--progression",
                1,
                "--fich-numeros",
                $fh->filename,
                "--extract-with",
                $extract_with,
                "--password",
                (
                      $config->get('pdf_password_use')
                    ? $config->get('pdf_password')
                    : ""
                ),
                "--students-list",
                $config->get_absolute('listeetudiants'),
                "--list-key",
                $config->get('liste_key'),
                "--password-key",
                $config->get('pdf_password_key'),
            ),
        ],
        quiet_regex  => 'Discarded not relevant field',
        signal       => 2,
        texte        => __ "Print papers one by one...",
        'progres.id' => 'impression',
        o            => {
            fh      => $fh,
            etu     => $options->{exams},
            printer => $config->get('imprimante'),
            method  => $options->{method},
        },
        fin => sub {
            my $c = shift;
            close( $c->{o}->{fh} );
            save_state_after_printing( $c->{o} );
        },

    );
}

sub save_state_after_printing {
    my $c  = shift;
    my $st = AMC::State::new( directory => $shortcuts->absolu('%PROJET/') );

    $st->read();

    my @files = grep { -f $shortcuts->absolu($_) }
      map { $config->get( 'doc_' . $_ ) }
      (qw/question solution setting catalog/);
    push @files, $config->get_absolute('texsrc');

    push @files, $config->get_absolute('filtered_source')
      if ( -f $config->get_absolute('filtered_source') );

    if ( !$st->check_local_md5(@files) ) {
        $st = AMC::State::new( directory => $shortcuts->absolu('%PROJET/') );
        $st->add_local_files(@files);
    }

    $st->add_print(
        printer => $c->{printer},
        method  => $c->{method},
        content => join( ',', @{ $c->{etu} } )
    );
    $st->write();

    detecte_mep();
}

sub calcule_mep {
    if ( $config->get('doc_setting') !~ /\.xy$/ ) {

        # OLD STYLE WORKING DOCUMENTS... Not supported anymore: update!
        my $dialog = Gtk3::MessageDialog->new(
            $w{main_window},
            'destroy-with-parent',
            'error',    # message type
            'ok',       # which set of buttons?
            ''
        );
        $dialog->set_markup(
            __(
"Working documents are in an old format, which is not supported anymore."
              )
              . " <b>"
              . __("Please generate again the working documents!") . "</b>"
        );
        $dialog->run;
        $dialog->destroy;

        return;
    }

    commande(
        commande => [
            "auto-multiple-choice",
            "meptex",
            "--debug",
            debug_file(),
            pack_args(
                "--src",            $config->get_absolute('doc_setting'),
                "--progression-id", 'MEP',
                "--progression",    1,
                "--data",           $config->get_absolute('data'),
            ),
        ],
        texte        => __ "Detecting layouts...",
        'progres.id' => 'MEP',
        fin          => sub {
            my ( $c, %data ) = @_;
            if ( $data{cancelled} ) {
                detecte_mep();
            } else {
                $projet{_layout}->begin_read_transaction('PGCN');
                my $c = $projet{_layout}->pages_count();
                my $sl_file =
                  $projet{_layout}->variable("build:studentslistfile");
                my $sl_key =
                  $projet{_layout}->variable("build:studentslistkey");
                my $extract_only =
                  $projet{_layout}->variable("build:extractonly");
                $projet{_layout}->end_transaction('PGCN');

                detecte_mep();

                if ( $c < 1 ) {

                    # avertissement...
                    my $dialog = Gtk3::MessageDialog->new(
                        $w{main_window},
                        'destroy-with-parent',
                        'error',    # message type
                        'ok',       # which set of buttons?
                        ''
                    );
                    $dialog->set_markup(
                        __("No layout detected.") . " "
                          . __(
"<b>Don't go through the examination</b> before fixing this problem, otherwise you won't be able to use AMC for correction."
                          )
                    );
                    $dialog->run;
                    $dialog->destroy;

                } else {
                    if ($sl_file) {
                        debug "SL_FILE=" . show_utf8($sl_file);
                        debug "SL_KEY =" . show_utf8($sl_key);
                        $config->set( 'listeetudiants',
                            $shortcuts->relatif_base($sl_file) );
                        $config->set( 'liste_key', $sl_key ) if ($sl_key);
                    }
                    if ($extract_only) {
                        scoring_strategy_update(0);
                    }

                    $learning->lesson('MAJ_MEP_OK');
                }
            }
        }
    );
}

sub verif_mep {
    saisie_manuelle( 0, 0, 1 );
}

### Actions des boutons de la partie SAISIE

sub saisie_manuelle {
    my ( $self, $event, $regarder ) = @_;
    $projet{_layout}->begin_read_transaction('PGCN');
    my $c = $projet{_layout}->pages_count();
    $projet{_layout}->end_transaction('PGCN');
    if ( $c > 0 ) {

        if ( !$regarder ) {
            # if auto_capture_mode is not set, ask the user...
            my $ok = AMC::Gui::AutoCapture->new(
                parent_window => $w{main_window},
                config        => $config,
            )->choose_mode();
            return () if ( !$ok );
        }

        # go for capture

        my $gm = AMC::Gui::Manuel::new(
            multiple         => $config->get('auto_capture_mode'),
            'data-dir'       => $config->get_absolute('data'),
            'project-dir'    => $shortcuts->absolu('%PROJET'),
            sujet            => $config->get_absolute('doc_question'),
            etud             => '',
            dpi              => $config->get('saisie_dpi'),
            seuil            => $config->get('seuil'),
            seuil_up         => $config->get('seuil_up'),
            seuil_sens       => $config->get('seuil_sens'),
            seuil_eqm        => $config->get('seuil_eqm'),
            global           => 0,
            encodage_interne => $config->get('encodage_interne'),
            image_type       => $config->get('manuel_image_type'),
            retient_m        => 1,
            editable         => ( $regarder ? 0 : 1 ),
            en_quittant      => (
                $regarder
                ? ''
                : sub { detecte_analyse(); assoc_state(); }
            ),
            size_monitor => {
                config => $config,
                key    => "global:"
                  . ( $regarder ? 'checklayout' : 'manual' )
                  . '_window_size'
            },
            invalid_color_name => $config->get("view_invalid_color"),
            empty_color_name   => $config->get("view_empty_color"),
        );
    } else {
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'error', 'ok', '' );
        $dialog->set_markup(
            __("No layout for this project.") . " "

              . sprintf(
# TRANSLATORS: Here, the first %s will be replaced with "Layout detection" (a button title), and the second %s with "Preparation" (the tab title where one can find this button).
                __(
"Please use button <i>%s</i> in <i>%s</i> before manual data capture."
                ),
                __ "Layout detection",
                __ "Preparation"
              )
        );
        $dialog->run;
        $dialog->destroy;
    }
}

sub saisie_automatique {

    AMC::Gui::AutoCapture->new(
        parent_window => $w{main_window},
        config        => $config,
        capture       => $projet{_capture},
        callback      => \&auto_data_capture,
    )->dialog();

}

sub analyse_call {
    my (%oo) = @_;

    # meeds a little tmp disk space (for zooms), and first decent space
    # for AMC-getimages...
    return () if ( !check_for_tmp_disk_space( $oo{getimages} ? 20 : 2 ) );

    # make temporary file with the list of images to analyse
    my $fh = File::Temp->new(
        TEMPLATE => "liste-XXXXXX",
        TMPDIR   => 1,
        UNLINK   => (get_debug() ? 0 : 1)
                            );
    binmode $fh, ":utf8";
    print $fh join( "\n", sort { $a cmp $b } @{ $oo{f} } ) . "\n";
    $fh->seek( 0, SEEK_END );

    # first try to see if some of the files are PDF forms

    $oo{fh}    = $fh;
    $oo{liste} = $fh->filename;

    commande(
        commande => [
            "auto-multiple-choice",
            "read-pdfform",
            "--debug",
            debug_file(),
            pack_args(
                "--progression-id",
                'analyse',
                "--list",
                $fh->filename,
                (
                    $config->get('auto_capture_mode')
                    ? "--multiple"
                    : "--no-multiple"
                ),
                "--data",
                $config->get_absolute('data'),
                "--password",
                $config->get('pdf_password')
            )
        ],
        signal => 2,
        o      => \%oo,
        fin    => sub {
            my ( $c, %data ) = @_;
            ${ $c->{o}->{overwritten} } += $c->variable('overwritten')
              if ( $c->{o}->{overwritten} && $c->variable('overwritten') );
            if ( !$data{cancelled} ) {
                analyse_call_images( %{ $c->{o} } );
            }
        },
        'progres.id' => $oo{progres},
    );
}

sub analyse_call_images {
    my (%oo) = @_;

    # extract individual images scans

    if ( $oo{getimages} ) {
        my @args = (
            "--progression-id", 'analyse',
            "--list",           $oo{fh}->filename,
            "--vector-density", $config->get('vector_scan_density'),
            "--password",       $config->get('pdf_password'),
        );
        push @args, "--copy-to", $oo{copy} if ( $oo{copy} );
        push @args, "--force-convert" if ( $config->get("force_convert") );
        $projet{_layout}->begin_transaction('Orie');
        my $orientation = $projet{_layout}->orientation();
        $projet{_layout}->end_transaction('Orie');
        push @args, "--orientation", $orientation if ($orientation);

        debug "Target orientation: $orientation";

        commande(
            commande => [
                "auto-multiple-choice", "getimages",
                "--debug",              debug_file(),
                pack_args(@args)
            ],
            signal       => 2,
            'progres.id' => $oo{progres},
            o            => \%oo,
            fin          => sub {
                my ( $c, %data ) = @_;
                if ( !$data{cancelled} ) {
                    analyse_call_go( %{ $c->{o} } );
                }
            },
        );
    } else {
        analyse_call_go(%oo);
    }
}

sub report_analyse_errors {
    my ($c) = @_;
    my @err = $c->erreurs();
    if (@err) {
        debug "Errors with AMC-analyse!";
        notify_end_of_work( 'capture', __("Data capture errors") );

        my $message = __("AMC had problems with your scans.");

        $message .= "\n\n"
          . __("<b>Errors</b>") . "\n"
          . join( "\n",
            map { format_markup($_) } ( @err[ 0 .. mini( 9, $#err ) ] ) )
          . (
            $#err > 9
            ? "\n\n<i>(" . __("Only first ten errors written") . ")</i>"
            : ""
          );

        $message .= "\n\n<b>" . __("Please have a look at these scans.")."</b>";

        debug($message);
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'error', 'ok', '' );
        $dialog->set_markup($message);
        $dialog->run;
        $dialog->destroy;
    }
    return (@err);
}

sub analyse_call_go {
    my (%oo) = @_;
    my @args = (
        ( $config->get('auto_capture_mode') ? "--multiple" : "--no-multiple" ),
        "--tol-marque",
        $config->get('tolerance_marque_inf') . ','
          . $config->get('tolerance_marque_sup'),
        "--prop",
        $config->get('box_size_proportion'),
        "--bw-threshold",
        $config->get('bw_threshold'),
        "--progression-id",
        'analyse',
        "--progression",
        1,
        "--n-procs",
        $config->get('n_procs'),
        "--data",
        $config->get_absolute('data'),
        "--projet",
        $shortcuts->absolu('%PROJET/'),
        "--cr",
        $config->get_absolute('cr'),
        "--liste-fichiers",
        $oo{liste},
        ( $config->get('ignore_red') ? "--ignore-red" : "--no-ignore-red" ),
        ( $config->get('try_three')  ? "--try-three"  : "--no-try-three" ),
    );

    push @args, "--pre-allocate", $oo{allocate} if ( $oo{allocate} );

    push @args, "--unlink-on-global-err" if($oo{copy});

    # Diagnostic image file ?

    if ( $oo{diagnostic} ) {
        push @args, "--debug-image-dir",
          $shortcuts->absolu('%PROJET/cr/diagnostic');
        push @args, "--no-tag-overwritten";
    }

    # call AMC-analyse

    commande(
        commande => [
            "auto-multiple-choice", "analyse",
            "--debug",              debug_file(),
            pack_args(@args)
        ],
        signal       => 2,
        texte        => $oo{text},
        'progres.id' => $oo{progres},
        o => {
            fh          => $oo{fh},
            overwritten => $oo{overwritten},
            diagnostic  => $oo{diagnostic}
          },
        fin          => sub {
            my ( $c, %data ) = @_;
            if ( !$c->{o}->{diagnostic} ) {
                report_analyse_errors($c);
            }
            debug "Overall [SCAN] overwritten pages @" . $c . ": "
              . ( $c->variable('overwritten') || "(none)" );
            ${ $c->{o}->{overwritten} } += $c->variable('overwritten')
              if ( $c->{o}->{overwritten} && $c->variable('overwritten') );
            debug "Calling original <fin> hook from analyse_call_go";
            &{ $oo{fin} }( $c, %data )
              if ( $oo{fin} );
        },
    );
}

sub decode_name_fields_again {
    decode_name_fields(1);
}

sub decode_name_fields {
    my ($all) = @_;

    my $type = $config->get('name_field_type');
    if ($type) {
        my $reg  = "AMC::Decoder::register::$type"->new();
        my $deps = $reg->check_dependencies();
        if ( !$deps->{ok} ) {
            my $message = sprintf(
                __(
"You selected the decoder \"<i>%s</i>\", which requires some tools that are missing on your system:"
                ),
                $reg->name()
            ) . "\n";
            if ( @{ $deps->{perl_modules} } ) {
                $message .= __("<b>Perl module(s):</b>") . " "
                  . join( ", ", @{ $deps->{perl_modules} } ) . "\n";
            }
            if ( @{ $deps->{commands} } ) {
                $message .= __("<b>Command(s):</b>") . " "
                  . join( ", ", @{ $deps->{commands} } ) . "\n";
            }
            $message .= __ "Install these dependencies and try again";

            my $dialog =
              Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
                'error', 'ok', '' );
            $dialog->set_markup($message);
            $dialog->run;
            $dialog->destroy;

            return ();
        }
    }

    commande(
        commande => [
            "auto-multiple-choice",
            "decode",
            "--debug",
            debug_file(),
            pack_args(
                "--data",
                $config->get_absolute('data'),
                "--cr",
                $config->get_absolute('cr'),
                "--project",
                $shortcuts->absolu('%PROJET/'),
                ( $all ? "--all" : "--no-all" ),
                "--decoder",
                $type,
                "--progression-id",
                'decode',
                "--progression",
                1,
            ),
        ],
        signal       => 2,
        texte        => __ "Decoding name field images...",
        'progres.id' => 'decode',
        fin          => \&update_available_codes,
    );
}

sub glib_project_name {
    return ( glib_filename( $projet{nom} ) );
}

sub auto_data_capture {
    my ($options) = @_;

    clear_old( 'diagnostic', $shortcuts->absolu('%PROJET/cr/diagnostic') );

    $w{annulation}->set_sensitive(1);

    my $overwritten = 0;

    analyse_call(
        f         => $options->{files},
        getimages => 1,
        copy => ( $options->{copy_files} ? $shortcuts->absolu('scans/') : '' ),
        text => __("Automatic data capture..."),
        progres     => 'analyse',
        allocate    => ( $config->get('allocate_ids') ? $options->{mcopy} : 0 ),
        overwritten => \$overwritten,
        fin         => sub {
            my ( $c, %data ) = @_;
            close( $c->{o}->{fh} );
            my @err = $c->erreurs();
            decode_name_fields();
            detecte_analyse( apprend => 1 );
            assoc_state();
            if ( !$data{cancelled} && !@err ) {
                notify_end_of_work( 'capture',
                    __ "Automatic data capture has been completed" );
            }
            my $ov = ${ $c->{o}->{overwritten} };
            if ( $ov > 0 ) {
                my $dialog = Gtk3::MessageDialog->new( $w{main_window},
                    'destroy-with-parent', 'warning', 'ok', '' );
                $dialog->set_markup(
                    sprintf(
                        __
"Some of the pages you submitted (%d of them) have already been processed before. Old data has been overwritten.",
                        $ov
                    )
                );
                $dialog->run;
                $dialog->destroy;
            }
        },
    );

}

sub choisit_liste {

    AMC::Gui::StudentsList->new(
        parent_window => $w{main_window},
        config        => $config,
        callback      => \&valide_liste
    )->dialog();

}

sub edite_liste {
    my $f = $config->get_absolute('listeetudiants');
    debug "Editing $f...";
    commande_parallele( $config->get('txt_editor'), $f );
}

sub students_list_show {
    $w{liste_refresh}->show();
    $monitor->remove_key( 'type', 'StudentsList' );
}

sub students_list_hide {
    $w{liste_refresh}->hide();
    $monitor->remove_key( 'type', 'StudentsList' );
    $monitor->add_file( $config->get_absolute('listeetudiants'),
        \&students_list_show, type => 'StudentsList' )
      if ( $config->get('listeetudiants') );
}

sub valide_liste {
    my %oo = @_;
    $oo{prefix} = 'pref_assoc' if ( !$oo{prefix} );
    $oo{gui} = $gui if ( !$oo{gui} );
    $oo{key} = 'liste_key' if ( !$oo{key} );
    $oo{prefs} = $prefs if( !$oo{prefs} );

    debug "* valide_liste";

    if ( defined( $oo{set} ) && !$oo{nomodif} ) {
        $config->set( 'listeetudiants', $shortcuts->relatif( $oo{set} ) );
    }

    my $fl = $config->get_absolute('listeetudiants');
    $fl = '' if ( !$config->get('listeetudiants') );

    my $fn = $fl;
    $fn =~ s/.*\///;

    # For proper markup rendering escape '<', '>' and '&' characters
    # in filename with \<, \gt;, and \&
    $fn = Glib::Markup::escape_text( glib_filename($fn) );

    if ( !$oo{nolabel} ) {
        if ($fl) {
            $w{liste_filename}->set_markup("<b>$fn</b>");
            $w{liste_filename}->set_tooltip_text( glib_filename($fl) );
            for (qw/liste_edit/) {
                $w{$_}->set_sensitive(1);
            }
        } else {

            # TRANSLATORS: Names list file : (none)
            $w{liste_filename}->set_markup( __ "(none)" );
            $w{liste_filename}->set_tooltip_text('');
            for (qw/liste_edit/) {
                $w{$_}->set_sensitive(0);
            }
        }
    }

    $projet{_students_list} = AMC::NamesFile::new(
        $fl,
        encodage    => bon_encodage('liste'),
        identifiant => csv_build_name(),
    );
    my ( $err, $errlig ) = $projet{_students_list}->errors();

    if ($err) {
        students_list_show();
        if ( !$oo{noinfo} ) {
            my $dialog =
              Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
                'error', 'ok', '' );
            $dialog->set_markup(
                sprintf(
                    __ "Unsuitable names file: %d errors, first on line %d.",
                    $err, $errlig
                )
            );
            $dialog->run;
            $dialog->destroy;
        }
        $oo{prefs}->store_register( $oo{key} => $cb_model_vide_key );
    } else {

        # problems with ID (name/surname)
        my $e = $projet{_students_list}->problem('ID.empty');
        if ( $e > 0 ) {
            debug "NamesFile: $e empty IDs";
            students_list_show();
            my $dialog =
              Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
                'warning', 'ok', '' );
            $dialog->set_markup(

# TRANSLATORS: Here, do not translate 'name' and 'surname' (except in french), as the column names in the students list file has to be named in english in order to be properly detected.
                sprintf( __
"Found %d empty names in names file <i>%s</i>. Check that <b>name</b> or <b>surname</b> column is present, and always filled.",
                    $e, $fn )
                  . " "
                  . __ "Edit the names file to correct it, and re-read."
            );
            $dialog->run;
            $dialog->destroy;
        } else {
            my $d = $projet{_students_list}->problem('ID.dup');
            if (@$d) {
                debug "NamesFile: duplicate IDs [" . join( ',', @$d ) . "]";
                if ( $#{$d} > 8 ) {
                    @$d = ( @{$d}[ 0 .. 8 ], '(and more)' );
                }
                students_list_show();
                my $dialog = Gtk3::MessageDialog->new( $w{main_window},
                    'destroy-with-parent', 'warning', 'ok', '' );
                $dialog->set_markup(
                    sprintf(
                        __
"Found duplicate names: <i>%s</i>. Check that all names are different.",
                        join( ', ', @$d )
                      )
                      . " "
                      . __ "Edit the names file to correct it, and re-read."
                );
                $dialog->run;
                $dialog->destroy;
            } else {

                # OK, no need to refresh
                students_list_hide();
            }
        }

        # transmission liste des en-tetes
        my @heads = $projet{_students_list}->heads_for_keys();
        debug "sorted heads: " . join( ",", @heads );

        # TRANSLATORS: you can omit the [...] part, just here to explain context
        $oo{prefs}->store_register(
            $oo{key} => cb_model(
                '',
                __p("(none) [No primary key found in association list]"),
                map { ( $_, $_ ) } (@heads)
            )
        );
    }
    $oo{prefs}->transmet_pref(
        $oo{gui},
        prefix => $oo{prefix},
        keys   => ["project:$oo{key}"]
    );
    assoc_state();
}

### Actions des boutons de la partie NOTATION

sub check_possible_assoc {
    my ($code) = @_;
    if ( !-s $config->get_absolute('listeetudiants') ) {
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'error', 'ok', '' );
        $dialog->set_markup(

            sprintf(
# TRANSLATORS: Here, %s will be replaced with the name of the tab "Data capture".
                __
"Before associating names to papers, you must choose a students list file in tab \"%s\".",
                __ "Data capture"
            )
        );
        $dialog->run;
        $dialog->destroy;
    } elsif ( !$config->get('liste_key') ) {
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'error', 'ok', '' );
        $dialog->set_markup(
            __(
"Please choose a key from primary keys in students list before association."
            )
        );
        $dialog->run;
        $dialog->destroy;
    } elsif ( $code && !$config->get('assoc_code') ) {
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'error', 'ok', '' );
        $dialog->set_markup(
            __(
"Please choose a code (made with LaTeX command \\AMCcodeGrid or equivalent) before automatic association."
            )
        );
        $dialog->run;
        $dialog->destroy;
    } else {
        return (1);
    }
    return (0);
}

# manual association
sub associe {
    return () if ( !check_possible_assoc(0) );
    if ( -f $config->get_absolute('listeetudiants') ) {
        my $ga = AMC::Gui::Association::new(
            cr          => $config->get_absolute('cr'),
            data_dir    => $config->get_absolute('data'),
            liste       => $config->get_absolute('listeetudiants'),
            liste_key   => $config->get('liste_key'),
            identifiant => csv_build_name(),

            'fichier-liens'  => $config->get_absolute('association'),
            global           => 0,
            'assoc-ncols'    => $config->get('assoc_ncols'),
            encodage_liste   => bon_encodage('liste'),
            encodage_interne => $config->get('encodage_interne'),
            rtl              => $config->get('annote_rtl'),
            fin              => sub {
                assoc_state();
            },
            size_prefs => ( $config->get('conserve_taille') ? $config : '' ),
        );
        if ( $ga->{erreur} ) {
            my $dialog =
              Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
                'error', 'ok', $ga->{erreur} );
            $dialog->run;
            $dialog->destroy;
        }
    } else {
        my $dialog = Gtk3::MessageDialog->new(
            $w{main_window},
            'destroy-with-parent',
            'info', 'ok',

            sprintf(
# TRANSLATORS: Here, %s will be replaced with "Students identification", which refers to a paragraph in the tab "Marking" from AMC main window.
                __
"Before associating names to papers, you must choose a students list file in paragraph \"%s\".",
                __ "Students identification"
            )
        );
        $dialog->run;
        $dialog->destroy;

    }
}

# automatic association
sub associe_auto {
    return () if ( !check_possible_assoc(1) );

    commande(
        commande => [
            "auto-multiple-choice",
            "association-auto",
            "--debug",
            debug_file(),
            pack_args(
                "--data",
                $config->get_absolute('data'),
                "--notes-id",
                $config->get('assoc_code'),
                "--liste",
                $config->get_absolute('listeetudiants'),
                "--liste-key",
                $config->get('liste_key'),
                "--csv-build-name",
                csv_build_name(),
                "--encodage-liste",
                bon_encodage('liste'),
                (
                    $config->get('assoc_code') eq '<preassoc>'
                    ? "--pre-association"
                    : "--no-pre-association"
                ),
            ),
        ],
        texte => __ "Automatic association...",
        fin   => sub {
            my ( $c, %data ) = @_;
            assoc_state();
            assoc_resultat() if ( !$data{cancelled} );
        },
    );
}

# automatic association finished : explain what to do after
sub assoc_resultat {
    my $mesg = 1;

    $projet{_association}->begin_read_transaction('ARCC');
    my ( $auto, $man, $both ) = $projet{_association}->counts();
    $projet{_association}->end_transaction('ARCC');

    my $dialog =
      Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
        'info', 'ok', '' );
    $dialog->set_markup(
        sprintf(
            __("Automatic association completed: %d students recognized."),
            $auto
          )
          .

          (
            $auto == 0
            ? "\n<b>"
              . sprintf(
# TRANSLATORS: Here %s and %s will be replaced with two parameters names: "Primary key from this list" and "Code name for automatic association".
                __("Please check \"%s\" and \"%s\" values and try again."),
                __("Primary key from this list"),
                __("Code name for automatic association")
              )
              . "</b>"
            : ""
          )
    );
    $dialog->run;
    $dialog->destroy;

    $learning->lesson('ASSOC_AUTO_OK') if ( $auto > 0 );
}

sub valide_options_correction {
    my ( $ww, $o ) = @_;
    my $name = $ww->get_name();
    debug "Options validation from $name";
    if ( !$w{$name} ) {
        debug "WARNING: Option validation failed, unknown name $name.";
    } else {
        $config->set( "project:$name", $w{$name}->get_active() ? 1 : 0 );
    }
}

my $previous_liste_key;

sub valide_options_association {
    $previous_liste_key = $config->get('liste_key');
    $prefs->valide_options_for_domain( 'pref_assoc', '', @_ );
}

sub valide_options_preparation {
    $prefs->valide_options_for_domain( 'pref_prep', '', @_ );
}

sub filter_changed {
    my (@args) = @_;

    # check it is a different value...

    my $old_filter = $config->get('filter');

    debug "Filter changed callback / old=$old_filter";

    $config->set_local_keys();
    $config->set( 'local:filter', $old_filter );
    $prefs->valide_options_for_domain( 'pref_prep', 'local', @_ );
    my $new_filter = $config->get('local:filter');
    return if ( $old_filter eq $new_filter );

    debug "Filter changed -> " . $new_filter;

    # working document already built: ask for confirmation

    if ( -f $config->get_absolute('doc_question') ) {
        debug "Ask for confirmation";
        my $text;
        if ( $projet{_capture}->n_pages_transaction() > 0 ) {
            $text = __(
"The working documents are already prepared with the current file format. If you change the file format, working documents and all other data for this project will be ereased."
              )
              . ' '
              . __("Do you wish to continue?") . " "
              . __(
"Click on Ok to erease old working documents and change file format, and on Cancel to get back to the same file format."
              )
              . "\n<b>"
              . __("To allow the use of an already printed question, cancel!")
              . "</b>";
        } else {
            $text = __(
"The working documents are already prepared with the current file format. If you change the file format, working documents will be ereased."
              )
              . ' '
              . __("Do you wish to continue?") . " "
              . __(
"Click on Ok to erease old working documents and change file format, and on Cancel to get back to the same file format."
              );
        }
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'question', 'ok-cancel', '' );
        $dialog->set_markup($text);
        my $reponse = $dialog->run;
        $dialog->destroy;

        if ( $reponse eq 'cancel' ) {
            $prefs->transmet_pref(
                $gui,
                prefix => 'pref_prep',
                root   => 'project:'
            );
            return (0);
        }

        clear_processing('doc:');

    }

    valide_options_preparation(@args);

    # No source created: change source filename

    if (  !-f $config->get_absolute('texsrc')
        || -z $config->get_absolute('texsrc') )
    {
        $config->set( 'project:texsrc',
            '%PROJET/'
              . ( "AMC::Filter::register::" . $config->get('filter') )
              ->default_filename() );
        $w{button_edit_src}->set_tooltip_text(
            glib_filename( $config->get_absolute('texsrc') ) );
    }

}

sub valide_options_notation {
    $prefs->valide_options_for_domain( 'notation', '', @_ );
    if ( $config->key_changed("regroupement_compose") ) {
        annotate_source_change( $projet{_capture}, 1 );
    }
    $w{groupe_model}
      ->set_sensitive( $config->get('regroupement_type') eq 'STUDENTS' );
}

sub change_liste_key {
    valide_options_association();

    debug "New liste_key: " . $config->get('liste_key');
    if ( $projet{_students_list}->head_n_duplicates( $config->get('liste_key') )
      )
    {
        debug "Invalid key: back to old value $previous_liste_key";

        my $dialog = Gtk3::MessageDialog->new(
            $w{main_window},
            'destroy-with-parent',
            'error',
            'ok',
            __
"You can't choose column '%s' as a key in the students list, as it contains duplicates (value '%s')",
            $config->get('liste_key'),
            $projet{_students_list}
              ->head_first_duplicate( $config->get('liste_key') ),
        );
        $dialog->run;
        $dialog->destroy;

        $config->set(
            'liste_key',
            (
                  $previous_liste_key ne $config->get('liste_key')
                ? $previous_liste_key
                : ""
            )
        );
        $prefs->transmet_pref(
            $gui,
            prefix => 'pref_assoc',
            keys   => ['project:liste_key']
        );
        return ();
    }
    if ( $config->get('liste_key') ) {

        $projet{_association}->begin_read_transaction('cLky');
        my $assoc_liste_key = $projet{_association}->variable('key_in_list');
        $assoc_liste_key = '' if ( !$assoc_liste_key );
        my ( $auto, $man, $both ) = $projet{_association}->counts();
        $projet{_association}->end_transaction('cLky');

        debug
"Association [$assoc_liste_key] counts: AUTO=$auto MANUAL=$man BOTH=$both";

        if (   $assoc_liste_key ne $config->get('liste_key')
            && $auto + $man > 0 )
        {
            # liste_key has changed and some association has been
            # made with another liste_key

            if ( $man > 0 ) {

                # manual association work has been made

                my $dialog = Gtk3::MessageDialog->new( $w{main_window},
                    'destroy-with-parent', 'warning', 'yes-no', '' );
                $dialog->set_markup(
                    sprintf(
                        __(
"The primary key from the students list has been set to \"%s\", which is not the value from the association data."
                        ),
                        $config->get('liste_key')
                      )
                      . " "
                      . sprintf(
                        __(
"Some manual association data has be found, which will be lost if the primary key is changed. Do you want to switch back to the primary key \"%s\" and keep association data?"
                        ),
                        $assoc_liste_key
                      )
                );
                $dialog->get_widget_for_response('yes')->get_style_context()
                  ->add_class("suggested-action");
                my $resp = $dialog->run;
                $dialog->destroy;

                if ( $resp eq 'no' ) {

                    # clears association data
                    clear_processing('assoc');

                    # automatic association run
                    if ( $config->get('assoc_code') && $auto > 0 ) {
                        associe_auto;
                    }
                } else {
                    $config->set( 'liste_key', $assoc_liste_key );
                    $prefs->transmet_pref(
                        $gui,
                        prefix => 'pref_assoc',
                        keys   => ['project:liste_key']
                    );
                }
            } else {
                if ( $config->get('assoc_code') ) {

                    # only automated association, easy to re-run
                    my $dialog = Gtk3::MessageDialog->new( $w{main_window},
                        'destroy-with-parent', 'info', 'ok', '' );
                    $dialog->set_markup(
                        sprintf(
                            __(
"The primary key from the students list has been set to \"%s\", which is not the value from the association data."
                            ),
                            $config->get('liste_key')
                          )
                          . " "
                          . __(
"Automatic papers/students association will be re-run to update the association data."
                          )
                    );
                    $dialog->run;
                    $dialog->destroy;

                    clear_processing('assoc');
                    associe_auto();
                }
            }
        }
    }
    assoc_state();
}

sub voir_notes {
    $projet{_scoring}->begin_read_transaction('smMC');
    my $c = $projet{_scoring}->marks_count;
    $projet{_scoring}->end_transaction('smMC');
    if ( $c > 0 ) {
        my $n = AMC::Gui::Notes::new(
            scoring    => $projet{_scoring},
            layout     => $projet{_layout},
            size_prefs => ( $config->get('conserve_taille') ? $config : '' ),
        );
    } else {
        my $dialog = Gtk3::MessageDialog->new(
            $w{main_window},
            'destroy-with-parent',
            'info', 'ok',
            sprintf(
                __ "Papers are not yet corrected: use button \"%s\".",

# TRANSLATORS: This is a button: "Mark" is here an action to be called by the user. When clicking this button, the user requests scores to be computed for all students.
                __ "Mark"
            )
        );
        $dialog->run;
        $dialog->destroy;
    }
}

# Get the number of copies used to build the working documents
sub original_n_copies {
    my $n = $projet{_layout}->variable_transaction('build:ncopies');
    if ( defined($n) && $n ne '' ) {
        $n = 0 if ( $n eq 'default' );
    } else {

        # Documents were built with an older AMC version: use value from GUI
        $n = $config->get('nombre_copies');
    }
    return ($n);
}

sub scoring_strategy_update {
    my ( $with_indiv_solution, %command_opts ) = @_;

    my $mode          = "b";
    my $pdf_corrected = $config->get_absolute('doc_indiv_solution');
    if ( -f $pdf_corrected ) {
        debug "Removing pre-existing $pdf_corrected";
        unlink($pdf_corrected);
    }
    $mode .= 'k' if ( $with_indiv_solution );

    commande(
        commande => [
            "auto-multiple-choice",
            "prepare",
            "--debug",
            debug_file(),
            pack_args(
                "--out-corrige-indiv",
                $pdf_corrected,
                "--n-copies",
                original_n_copies(),
                "--with",
                moteur_latex(),
                "--filter",
                $config->get('filter'),
                "--filtered-source",
                $config->get_absolute('filtered_source'),
                "--progression-id",
                'bareme',
                "--progression",
                1,
                "--data",
                $config->get_absolute('data'),
                "--mode",
                $mode,
                $config->get_absolute('texsrc'),
            ),
        ],
        texte        => __ "Extracting marking scale...",
        'progres.id' => 'bareme',
        %command_opts
    );
}

sub noter {
    if ( $config->get('maj_bareme') ) {

        scoring_strategy_update(
            $config->get('prepare_indiv_solution'),
            fin => sub {
                my ( $c, %data ) = @_;
                check_sty_version($c);
                noter_postcorrect();
            },
        );

    } else {
        noter_calcul( '', '' );
    }
}

sub noter_postcorrect {
    my ( $c, %data ) = @_;

    detecte_documents();

    return if ( $data{cancelled} );

    # check marking scale data: in PostCorrect mode, ask for a sheet
    # number to get right answers from...

    if ( $projet{_scoring}->variable_transaction('postcorrect_flag') ) {

        debug "PostCorrect option ON";

        # Let the user choose the reference copy

        my $pc = AMC::Gui::Postcorrect->new(
            parent_window => $w{main_window},
            config        => $config,
            capture       => $projet{_capture}
        );
        $pc->choose_reference( \&noter_calcul );

    } else {
        noter_calcul( '', '' );
    }
}

sub noter_calcul {

    my ( $postcorrect_student, $postcorrect_copy, $postcorrect_set_multiple ) =
      @_;

    debug
"Using sheet $postcorrect_student:$postcorrect_copy to get correct answers"
      if ($postcorrect_student);

    # computes marks.

    commande(
        commande => [
            "auto-multiple-choice",
            "note",
            "--debug",
            debug_file(),
            pack_args(
                "--data",     $config->get_absolute('data'),
                "--seuil",    $config->get('seuil'),
                "--seuil-up", $config->get('seuil_up'),

                "--grain",
                $config->get('note_grain'),
                "--arrondi",
                $config->get('note_arrondi'),
                "--notemax",
                $config->get('note_max'),
                (
                    $config->get('note_max_plafond') ? "--plafond"
                    : "--no-plafond"
                ),
                "--notenull",
                $config->get('note_null'),
                "--notemin",
                $config->get('note_min'),
                "--postcorrect-student",
                $postcorrect_student,
                "--postcorrect-copy",
                $postcorrect_copy,
                (
                    $postcorrect_set_multiple ? "--postcorrect-set-multiple"
                    : "--no-postcorrect-set-multiple"
                ),

                "--progression-id",
                'notation',
                "--progression",
                1,
            ),
        ],
        signal       => 2,
        texte        => __ "Computing marks...",
        'progres.id' => 'notation',
        fin          => sub {
            my ( $c, %data ) = @_;
            notify_end_of_work( 'grading', __ "Grading has been completed" )
              if ( !$data{cancelled} );
            noter_resultat();
        },
    );
}

sub noter_resultat {
    $projet{_scoring}->begin_read_transaction('MARK');
    my $avg = $projet{_scoring}->average_mark;
    $projet{_scoring}->end_transaction('MARK');

    my $ok;
    my $text;
    if ( defined($avg) ) {
        $ok = 'info';

        # TRANSLATORS: This is the marks mean for all students.
        $text = sprintf( __ "Mean: %.2f", $avg );
    } else {
        $ok   = 'error';
        $text = __("No marks computed");
    }
    set_state( 'marking', $ok, $text );
    update_available_codes();
    $w{onglet_reports}->set_sensitive( defined($avg) );
}

my $assoc_code_name = {
# TRANSLATORS: menu item when choosing the code to use for association from the completed answer sheets. This item corresponds to pre-association (each student has an individualized sheet)
    '<preassoc>' => __ "Pre-association",
# TRANSLATORS: menu item when choosing the code to use for association from the completed answer sheets. This item corresponds to the decoded name field (eg. when a barcode identifying the student has been sticked in the name field)
    '_namefield' => __ "Decoded name field",
};

sub update_available_codes {
    $projet{_scoring}->begin_read_transaction('CODE');

    my @codes     = $projet{_scoring}->codes;
    my $pre_assoc = $projet{_layout}->pre_association();

    $projet{_scoring}->end_transaction('CODE');

    if ($pre_assoc) {
        push @codes, '<preassoc>';
    }

    debug "Codes : " . join( ',', @codes );

    # TRANSLATORS: you can omit the [...] part, just here to explain context
    my @cbs = ( '' => __p("(none) [No code found in LaTeX file]") );
    if ( my $el = get_enc( $config->get('encodage_latex') ) ) {
        push @cbs,
          map { $_ => $assoc_code_name->{$_} || decode( $el->{iso}, $_ ) }
          (@codes);
    } else {
        push @cbs, map { $_ => $assoc_code_name->{$_} || $_ } (@codes);
    }
    $prefs->store_register( assoc_code => cb_model(@cbs) );
    $prefs->transmet_pref(
        $gui,
        prefix => 'pref_assoc',
        keys   => ['project:assoc_code']
    );
}

sub assoc_state {
    my $i = 'question';
    my $t = '';
    my $some = 0;
    if ( !-s $config->get_absolute('listeetudiants') ) {
        $t = __ "No students list file";
    } elsif ( !$config->get('liste_key') ) {
        $t = __ "No primary key from students list file";
    } else {
        $projet{_association}->begin_read_transaction('ARST');
        my $mc = $projet{_association}->missing_count;
        my ( $auto, $man, $both ) = $projet{_association}->counts();
        $projet{_association}->end_transaction('ARST');
        $some = ( $auto > 0 || $man > 0 );
        if ($mc) {
            $t = sprintf(
                ( __ "Missing identification for %d answer sheets" ),
                $mc
            );
        } else {
            $t = __
              "All completed answer sheets are associated with a student name";
            $i = 'info';
        }
    }
    set_state( 'assoc', $i, $t );
    if($some) {
        $w{send_subject_config_button}->hide();
    } else {
        $w{send_subject_config_button}->show();
    }
}

sub opt_symbole {
    my ($s) = @_;
    my $k = $s;

    $k =~ s/-/_/g;
    my $type  = $config->get( 'symbole_' . $k . '_type',  'none' );
    my $color = $config->get( 'symbole_' . $k . '_color', 'red' );

    return ("$s:$type/$color");
}

sub select_students {
    my ($id_file) = @_;

    AMC::Gui::SelectStudents->new(
        parent_window => $w{main_window},
        config        => $config,
        capture       => $projet{_capture},
        association   => $projet{_association},
        students_list => $projet{_students_list},
        id_file       => $id_file,
    );

}

sub annote_copies {
    my $id_file = '';

    if ( $config->get('regroupement_copies') eq 'SELECTED' ) {

        # use a file in project directory to store students ids for which
        # sheets will be annotated
        $id_file = $shortcuts->absolu('%PROJET/selected-ids');
        return () if ( !select_students($id_file) );
    }

    my $single_output = '';

    if ( $config->get('regroupement_type') eq 'ALL' ) {
        $single_output = (
            $id_file
            ?

# TRANSLATORS: File name for single annotated answer sheets with only some selected students. Please use simple characters.
              ( __("Selected_students") ) . ".pdf"
            :

# TRANSLATORS: File name for single annotated answer sheets with all students. Please use simple characters.
              ( __("All_students") ) . ".pdf"
        );
    }

    commande(
        commande => [
            "auto-multiple-choice",
            "annotate",
            "--debug",
            debug_file(),
            pack_args(
                "--cr",
                $config->get_absolute('cr'),
                "--project",
                $shortcuts->absolu('%PROJET/'),
                "--projects",
                $shortcuts->absolu('%PROJETS/'),
                "--data",
                $config->get_absolute('data'),
                "--subject",
                $config->get_absolute('doc_question'),
                "--corrected",
                $config->get_absolute('doc_indiv_solution'),
                "--filename-model",
                $config->get('modele_regroupement'),
                (
                    $config->get('ascii_filenames') ? "--force-ascii"
                    : "--no-force-ascii"
                ),
                "--single-output",
                $single_output,
                "--sort",
                $config->get('export_sort'),
                "--id-file",
                $id_file,
                "--progression-id",
                'annotate',
                "--progression",
                1,
                "--line-width",
                $config->get('symboles_trait'),
                "--font-name",
                $config->get('annote_font_name'),
                "--symbols",
                join( ',', map { opt_symbole($_); } (qw/0-0 0-1 1-0 1-1/) ),
                (
                    $config->get('symboles_indicatives') ? "--indicatives"
                    : "--no-indicatives"
                ),
                "--position",
                $config->get('annote_position'),
                "--dist-to-box",
                $config->get('annote_ecart'),
                "--n-digits",
                $config->get('annote_chsign'),
                "--verdict",
                $config->get('verdict'),
                "--verdict-question",
                $config->get('verdict_q'),
                "--verdict-question-cancelled",
                $config->get('verdict_qc'),
                "--names-file",
                $config->get_absolute('listeetudiants'),
                "--names-encoding",
                bon_encodage('liste'),
                "--csv-build-name",
                csv_build_name(),
                ( $config->get('annote_rtl') ? "--rtl" : "--no-rtl" ),
                "--changes-only",
                1, "--sort",
                $config->get('export_sort'),
                "--compose",
                $config->get('regroupement_compose'),
                "--n-copies",
                original_n_copies(),
                "--src",
                $config->get_absolute('texsrc'),
                "--with",
                moteur_latex(),
                "--filter",
                $config->get('filter'),
                "--filtered-source",
                $config->get_absolute('filtered_source'),
                "--embedded-max-size",
                $config->get('embedded_max_size'),
                "--embedded-format",
                $config->get('embedded_format'),
                "--embedded-jpeg-quality",
                $config->get('embedded_jpeg_quality'),
            )
        ],
        texte        => __ "Annotating papers...",
        'progres.id' => 'annotate',
        fin          => sub {
            my ( $c, %data );
            notify_end_of_work( 'annotation',
                __ "Annotations have been completed" )
              if ( !$data{cancelled} );
        },
    );
}

sub annotate_papers {

    valide_options_notation();
    maj_export();

    annote_copies;
}

sub view_dir {
    my ($dir) = @_;

    debug "Look at $dir";
    my $seq = 0;
    my @c   = map { $seq += s/[%]d/$dir/g;  $_; }
      split( /\s+/, $config->get('dir_opener') );
    push @c, $dir if ( !$seq );

    commande_parallele(@c);
}

sub open_exports_dir {
    view_dir( $shortcuts->absolu('%PROJET/exports/') );
}

sub open_templates_dir {
    view_dir( $config->get('rep_modeles') );
}

sub regarde_regroupements {
    view_dir( $config->get_absolute('cr') . "/corrections/pdf" );
}

sub plugins_browse {
    view_dir( $config->subdir("plugins") );
}

###

sub activate_apropos {

    AMC::Gui::APropos->new( parent_window => $w{main_window} );

}

sub activate_doc {
    my ( $w, $lang ) = @_;

    if ( !$lang ) {
        my $n = $w->Gtk3::Buildable::get_name;
        if ( $n =~ /_([a-z]{2})$/ ) {
            $lang = $1;
        }
    }

    my $url = 'file://' . $hdocdir;
    $url .= "auto-multiple-choice.$lang/index.html"
      if ( $lang && -f $hdocdir . "auto-multiple-choice.$lang/index.html" );

    my $seq = 0;
    my @c   = map { $seq += s/[%]u/$url/g; $_; }
      split( /\s+/, $config->get('html_browser') );
    push @c, $url if ( !$seq );

    commande_parallele(@c);
}

###

sub edit_preferences {

    AMC::Gui::Preferences->new(
        parent_window            => $w{main_window},
        config                   => $config,
        widgets                  => \%w,
        capture                  => $projet{_capture},
        decode_callback          => \&decode_name_fields_again,
        detect_analysis_callback => \&detecte_analyse,
        test_libnotify_callback  => \&test_libnotify,
        open_project_name        => $projet{nom},
    );

}

sub sauve_pref_generales {
    $config->save();
}

sub file_maj {
    my (@f)     = @_;
    my $present = 1;
    my $oldest  = 0;
    for my $file (@f) {
        if ( $file && -f $file ) {
            if ( -r $file ) {
                my @s = stat($file);
                $oldest = $s[9] if ( $s[9] > $oldest );
            } else {
                return ('UNREADABLE');
            }
        } else {
            return ('NOTFOUND');
        }
    }
    return ( format_date($oldest) );
}

sub open_documents_popover {
    if ( $w{toggle_documents}->get_active() ) {
        $w{documents_popover}->show_all();
    } else {
        $w{documents_popover}->hide();
    }
    return (1);
}

sub popover_hidden {
    $w{toggle_documents}->set_active(0) if ( $w{toggle_documents} );
    return (1);
}

sub check_document {
    my ( $filename, $k ) = @_;
    debug( "Document $filename " . ( -f $filename ? "exists" : "NOT FOUND" ) );
    $w{ 'but_' . $k }->set_sensitive( -f $filename );
}

sub set_state {
    my ( $k, $type, $message ) = @_;
    if ( defined($type) && $w{ 'state_' . $k } ) {
        if ( $type eq 'none' ) {
            $w{ 'state_' . $k }->hide();
        } else {
            $w{ 'state_' . $k }->show();
            $w{ 'state_' . $k }->set_message_type($type);
        }
    }
    $w{ 'state_' . $k . '_label' }->set_text($message)
      if ( defined($message) && $w{ 'state_' . $k . '_label' } );
}

sub detecte_documents {
    check_document( $config->get_absolute('doc_question'), 'question' );
    check_document( $config->get_absolute('doc_solution'), 'solution' );
    check_document( $config->get_absolute('doc_indiv_solution'),
        'indiv_solution' );
    check_document( $config->get_absolute('doc_catalog'), 'catalog' );
    my $s = file_maj( map { $config->get_absolute( 'doc_' . $_ ) }
          (qw/question setting/) );
    my $ok;
    if ( $s eq 'UNREADABLE' ) {
        $s  = __("Working documents are not readable");
        $ok = 'error';
    } elsif ( $s eq 'NOTFOUND' ) {
        $s  = __("No working documents");
        $ok = 'warning';
    } else {
        $s  = __("Working documents last update:") . " " . $s;
        $ok = 'info';
    }
    if ( $ok eq 'info' ) {
        $w{toggle_documents}->show();
    } else {
        $w{toggle_documents}->set_active(0);
        $w{toggle_documents}->hide();
    }
    set_state( 'docs', $ok, $s );
}

sub show_document {
    my ($sel) = @_;
    my $f = $config->get_absolute( 'doc_' . $sel );
    debug "Looking at $f...";
    commande_parallele( $config->get('pdf_viewer'), $f );
}

sub show_question {
    show_document('question');
}

sub show_solution {
    show_document('solution');
}

sub show_indiv_solution {
    show_document('indiv_solution');
}

sub show_catalog {
    show_document('catalog');
}

sub update_catalog { update_document( "C", partial => 1 ); }

sub update_solution { update_document( "S", partial => 1 ); }

sub update_indiv_solution { update_document( "k", partial => 1 ); }

sub detecte_mep {
    $projet{_layout}->begin_read_transaction('LAYO');
    $projet{_mep_defauts} = { $projet{_layout}->defects() };
    my $c = $projet{_layout}->pages_count;
    my $subjects_printed = $projet{_report}->n_printed() > 0;
    $projet{_layout}->end_transaction('LAYO');
    my @def = ( keys %{ $projet{_mep_defauts} } );
    if (@def) {
        $w{button_mep_warnings}->show();
    } else {
        $w{button_mep_warnings}->hide();
    }
    $w{onglet_saisie}->set_sensitive( $c > 0 );
    my $s;
    my $ok;
    if ( $c < 1 ) {
        $s  = __("No layout");
        $ok = 'error';
    } else {
        $s = sprintf( __("Processed %d pages"), $c );
        if (@def) {
            $s .= ", " . __("but some defects were detected.");
            $ok = defects_class(@def);
        } else {
            $s .= '.';
            $ok = 'info';
        }
    }
    set_state( 'layout', $ok, $s );

    if ($subjects_printed) {
        $w{send_subject_action}->show();
    } else {
        $w{send_subject_action}->hide();
    }
}

my %defect_text = (
    NO_NAME => __(
"The \\namefield command is not used. Writing subjects without name field is not recommended"
    ),
    SEVERAL_NAMES => __(
"The \\namefield command is used several times for the same subject. This should not be the case, as each student should write his name only once"
    ),
    NO_BOX              => __("No box to be ticked"),
    DIFFERENT_POSITIONS => __(
"The corner marks and binary boxes are not at the same location on all pages"
    ),
    OUT_OF_PAGE => __(
"Some material has been placed out of the page. This is often a result of a multiple columns question group starting too close from the page bottom. In such a case, use \"needspace\"."
    ),
);

sub defects_class {
    my (@defects) = @_;
    my $w         = 0;
    my $e         = 0;
    for my $k (@defects) {
        if ( $k eq 'NO_NAME' ) {
            $w++;
        } else {
            $e++;
        }
    }
    return ( $e ? 'error' : $w ? 'question' : 'info' );
}

sub mep_warnings {
    my $m   = '';
    my @def = ( keys %{ $projet{_mep_defauts} } );
    if (@def) {
        $m = __(
"Some potential defects were detected for this subject. Correct them in the source and update the working documents."
        );
        for my $k ( keys %defect_text ) {
            my $dd = $projet{_mep_defauts}->{$k};
            if ($dd) {
                if ( $k eq 'DIFFERENT_POSITIONS' ) {
                    $m .= "\n<b>"
                      . $defect_text{$k} . "</b> "
                      . sprintf(
                        __('(See for example pages %s and %s)'),
                        pageids_string( $dd->{student_a}, $dd->{page_a} ),
                        pageids_string( $dd->{student_b}, $dd->{page_b} )
                      ) . '.';
                } elsif ( $k eq 'OUT_OF_PAGE' ) {
                    $m .= "\n<b>"
                      . $defect_text{$k} . "</b> "
                      . sprintf(
                        __('(Concerns %1$d pages, see for example page %2$s)'),
                        1 + $#{$dd},
                        pageids_string( $dd->[0]->{student}, $dd->[0]->{page} )
                      ) . '.';
                } else {
                    my @e = sort { $a <=> $b } ( @{$dd} );
                    if (@e) {
                        $m .= "\n<b>"
                          . $defect_text{$k} . "</b> "
                          . sprintf(
                            __(
'(Concerns %1$d exams, see for example sheet %2$d)'
                            ),
                            1 + $#e,
                            $e[0]
                          ) . '.';
                    }
                }
            }
        }
    } else {

        # should not be possible to go there...
        return ();
    }
    my $dialog =
      Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
        'warning', 'ok', '' );
    $dialog->set_markup($m);
    $dialog->run;
    $dialog->destroy;

}

sub clear_processing {
    my ($steps) = @_;
    my $next    = '';
    my %s       = ();
    for my $k (qw/doc mep capture mark assoc/) {
        if ( $steps =~ /\b$k:/ ) {
            $next = 1;
            $s{$k} = 1;
        } elsif ( $next || $steps =~ /\b$k\b/ ) {
            $s{$k} = 1;
        }
    }

    if ( $s{doc} ) {
        for (qw/question solution setting catalog/) {
            my $f = $config->get_absolute( 'doc_' . $_ );
            unlink($f) if ( -f $f );
        }
        detecte_documents();
    }

    delete( $s{doc} );
    return () if ( !%s );

    # data to remove...

    $projet{_data}->begin_transaction('CLPR');

    if ( $s{mep} ) {
        $projet{_layout}->clear_all;
    }

    if ( $s{capture} ) {
        $projet{_capture}->clear_all;
    }

    if ( $s{mark} ) {
        $projet{_scoring}->clear_strategy;
        $projet{_scoring}->clear_score;
    }

    if ( $s{assoc} ) {
        $projet{_association}->clear;
    }

    $projet{_data}->end_transaction('CLPR');

    # files to remove...

    if ( $s{capture} ) {

        # remove zooms
        remove_tree(
            $shortcuts->absolu('%PROJET/cr/zooms'),
            { verbose => 0, safe => 1, keep_root => 1 }
        );

        # remove namefield extractions and page layout image
        my $crdir = $shortcuts->absolu('%PROJET/cr');
        opendir( my $dh, $crdir );
        my @cap_files = grep { /^(name-|page-)/ } readdir($dh);
        closedir($dh);
        for (@cap_files) {
            unlink "$crdir/$_";
        }
    }

    # update gui...

    if ( $s{mep} ) {
        detecte_mep();
    }
    if ( $s{capture} ) {
        detecte_analyse();
    }
    if ( $s{mark} ) {
        noter_resultat();
    }
    if ( $s{assoc} ) {
        assoc_state();
    }
}

sub update_analysis_summary {
    my $n = $projet{_capture}->n_pages;

    my %r = $projet{_capture}->counts;

    $r{npages} = $n;

    my $failed_nb =
      $projet{_capture}->sql_single( $projet{_capture}->statement('failedNb') );

    my $ow = $projet{_capture}->n_overwritten || 0;

    $w{onglet_notation}->set_sensitive( $n > 0 );

    # resume

    my $tt = '';
    my $ok = 'info';
    if ( $r{incomplete} ) {
        $tt = sprintf(
            __ "Data capture from %d complete papers and %d incomplete papers",
            $r{complete}, $r{incomplete} );
        $ok = 'error';
        $w{button_show_missing}->show();
    } elsif ( $r{complete} ) {
        $tt =
          sprintf( __("Data capture from %d complete papers"), $r{complete} );
        $ok = 'info';
        $w{button_show_missing}->hide();
    } else {

     # TRANSLATORS: this text points out that no data capture has been made yet.
        $tt = sprintf( __ "No data" );
        $ok = 'error';
        $w{button_show_missing}->hide();
    }
    set_state( 'capture', $ok, $tt );

    if ( $ow > 0 ) {
        set_state( 'overwritten', 'warning',
            sprintf( __ "Overwritten pages: %d", $ow ) );
        $w{state_overwritten}->show();
    } else {
        $w{state_overwritten}->hide();
    }

    if ( $failed_nb <= 0 ) {
        if ( $r{complete} ) {
            $tt = __ "All scans were properly recognized.";
            $ok = 'none';
        } else {
            $tt = "";
            $ok = 'none';
        }
    } else {
        $tt = sprintf( __ "%d scans were not recognized.", $failed_nb );
        $ok = 'question';
    }
    set_state( 'unrecognized', $ok, $tt );

    return ( \%r );
}

sub overwritten_clear {
    $projet{_capture}->begin_transaction('OWcl');
    $projet{_capture}->clear_overwritten();
    update_analysis_summary();
    $projet{_capture}->end_transaction('OWcl');
}

sub overwritten_look {
    AMC::Gui::Overwritten->new(
        parent_window => $w{main_window},
        config        => $config,
        capture       => $projet{_capture}
    );
}

sub detecte_analyse {
    my (%oo) = (@_);
    my $iter;
    my $row;

    new_diagstore();

    $w{commande}->show();
    my $av_text = $w{avancement}->get_text();
    my $frac;
    my $total;
    my $i;

    $projet{_capture}->begin_read_transaction('ADCP');

    my $summary = $projet{_capture}->summaries(
        darkness_threshold    => $config->get('seuil'),
        darkness_threshold_up => $config->get('seuil_up'),
        sensitivity_threshold => $config->get('seuil_sens'),
        mse_threshold         => $config->get('seuil_eqm')
    );

    $total = $#{$summary} + 1;
    $i     = 0;
    $frac  = 0;
    if ( $total > 0 ) {
        $w{avancement}->set_text( __ "Looking for analysis..." );
        Gtk3::main_iteration while (Gtk3::events_pending);
    }
    for my $p (@$summary) {
        $diag_store->insert_with_values(
            $i,
            DIAG_ID,
            pageids_string( $p->{student}, $p->{page}, $p->{copy} ),
            DIAG_ID_STUDENT,
            $p->{student},
            DIAG_ID_PAGE,
            $p->{page},
            DIAG_ID_COPY,
            $p->{copy},
            DIAG_ID_BACK,
            $p->{color},
            DIAG_EQM,
            $p->{mse_string},
            DIAG_EQM_BACK,
            $p->{mse_color},
            DIAG_MAJ,
            format_date( $p->{timestamp} ),
            DIAG_MAJ_NUM,
            $p->{timestamp},
            DIAG_DELTA,
            $p->{sensitivity_string},
            DIAG_DELTA_BACK,
            $p->{sensitivity_color},
            DIAG_SCAN_FILE,
            path_to_filename( $p->{src} ),
        );
        if ( $i / $total >= $frac + .05 ) {
            $frac = $i / $total;
            $w{avancement}->set_fraction($frac);
            Gtk3::main_iteration while (Gtk3::events_pending);
        }
    }

    sort_diagstore();
    show_diagstore();

    $w{avancement}->set_text($av_text);
    $w{avancement}->set_fraction(0) if ( !$oo{interne} );
    $w{commande}->hide() if ( !$oo{interne} );
    Gtk3::main_iteration while (Gtk3::events_pending);

    my $r = update_analysis_summary();

    $projet{_capture}->end_transaction('ADCP');

    # dialogue apprentissage :

    if ( $oo{apprend} ) {
        $learning->lesson('SAISIE_AUTO', $r);
    }

}

sub show_missing_pages {
    $projet{_capture}->begin_read_transaction('cSMP');
    my %r = $projet{_capture}->counts;
    $projet{_capture}->end_transaction('cSMP');

    my $l  = '';
    my @sc = ();
    for my $p ( @{ $r{missing} } ) {
        if ( $sc[0] != $p->{student} || $sc[1] != $p->{copy} ) {
            @sc = ( $p->{student}, $p->{copy} );
            $l .= "\n";
        }
        $l .= "  " . pageids_string( $p->{student}, $p->{page}, $p->{copy} );
    }

    my $dialog =
      Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
        'info', 'ok', '' );
    $dialog->set_markup( "<b>"
          . ( __ "Pages that miss data capture to complete students sheets:" )
          . "</b>"
          . $l );
    $dialog->run;
    $dialog->destroy;
}

sub open_unrecognized {

    AMC::Gui::Unrecognized->new(
        parent_window            => $w{main_window},
        config                   => $config,
        capture                  => $projet{_capture},
        update_analysis_callback => \&update_analysis_summary,
        analysis_callback        => \&analyse_call,
    );

}

sub set_source_tex {
    my ($importe) = @_;

    importe_source() if ($importe);
    valide_source_tex();
}

sub valide_source_tex {
    debug "* valide_source_tex";

    $w{button_edit_src}
      ->set_tooltip_text( glib_filename( $config->get_absolute('texsrc') ) );

    if ( !$config->get('filter') ) {
        $config->set( 'filter',
            best_filter_for_file( $config->get_absolute('texsrc') ) );
    }

    detecte_documents();
}

sub make_template {

    if ( !$projet{nom} ) {
        debug "Make template: no opened project";
        return ();
    }

    projet_check_and_save();

    AMC::Gui::Template->new(
        parent_window => $w{main_window},
        config        => $config,
        project_name  => $projet{nom},
    );

}

sub source_latex_choisir {
    my %oo = @_;

    my $create = AMC::Gui::CreateProject->new(
        parent_window  => $w{main_window},
        config         => $config,
        filter_modules => \@filter_modules,
    );

    return ( $create->install_source(%oo) );
}

sub importe_source {
    my $file = $config->get('texsrc');
    my ( $fxa, $fxb, $fb ) = splitpath($file);
    my $dest = $shortcuts->absolu($fb);

    # fichier deja dans le repertoire projet...
    return () if ( is_local( $file, 1 ) );

    if ( -f $dest ) {
        my $dialog = Gtk3::MessageDialog->new(
            $w{main_window},
            'destroy-with-parent',
            'error', 'yes-no',
            __(
"File %s already exists in project directory: do you want to replace it?"
              )
              . " "
              . __(
"Click yes to replace it and loose pre-existing contents, or No to cancel source file import."
              ),
            $fb
        );
        my $reponse = $dialog->run;
        $dialog->destroy;

        if ( $reponse eq 'no' ) {
            return (0);
        }
    }

    if ( AMC::Gui::CreateProject->copy_latex( $config->get_absolute('texsrc'), $dest, $config->get('encodage_latex') ) ) {
        $config->set( 'project:texsrc', $shortcuts->relatif($dest) );
        set_source_tex();
        my $dialog = Gtk3::MessageDialog->new(
            $w{main_window},
            'destroy-with-parent',
            'info', 'ok',
            __("The source file has been copied to project directory.") . " "
              . sprintf(
                __ "You can now edit it with button \"%s\" or with any editor.",
                __ "Edit source file"
              )
        );
        $dialog->run;
        $dialog->destroy;
    } else {
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'error', 'ok', __ "Error copying source file: %s", $! );
        $dialog->run;
        $dialog->destroy;
    }
}

sub edit_src {
    my $f = $config->get_absolute('texsrc');

    # create new one if necessary

    if ( !-f $f ) {
        debug "Creating new empty source file...";
        ( "AMC::Filter::register::" . $config->get('filter') )
          ->default_content($f);
    }

    #

    debug "Editing $f...";
    my $editor = $config->get('txt_editor');
    if ( $config->get('filter') ) {
        my $type =
          ( "AMC::Filter::register::" . $config->get('filter') )->filetype();
        $editor = $config->get( $type . '_editor' )
          if ( $config->get( $type . '_editor' ) );
    }
    commande_parallele( $editor, $f );
}

sub valide_projet {
    set_source_tex();

    $projet{_data} =
      AMC::Data->new( $config->get_absolute('data'), progress => \%w );
    for (qw/layout capture scoring association report/) {
        $projet{ '_' . $_ } = $projet{_data}->module($_);
    }

    $projet{_students_list} = AMC::NamesFile::new();

    detecte_mep();
    detecte_analyse( premier => 1 );

    debug "Correction options : MB" . $config->get('maj_bareme');
    $w{maj_bareme}->set_active( $config->get('maj_bareme') );

    $prefs->transmet_pref(
        $gui,
        prefix => 'notation',
        root   => 'project:'
    );

    $w{header_bar}
      ->set_title( glib_project_name . ' - ' . 'Auto Multiple Choice' );

    noter_resultat();

    valide_liste( noinfo => 1, nomodif => 1 );

    # options specific to some export module:
    $prefs->transmet_pref( '', prefix => 'export', root => 'project:' );

    # standard export options:
    $prefs->transmet_pref( $gui, prefix => 'export', root => 'project:' );

    $prefs->transmet_pref( $gui, prefix => 'pref_prep', root => 'project:' );

    for my $k (@widgets_only_when_opened) {
        $w{$k}->set_sensitive(1);
    }
}

sub cursor_wait {
    $w{cursor_watch} = Gtk3::Gdk::Cursor->new('GDK_WATCH')
      if ( !$w{cursor_watch} );
    $w{main_window}->get_window()->set_cursor( $w{cursor_watch} )
      if ( $w{main_window} );
    Gtk3::main_iteration while (Gtk3::events_pending);
}

sub cursor_standard {
    $w{main_window}->get_window()->set_cursor(undef)
      if ( $w{main_window} );
    Gtk3::main_iteration while (Gtk3::events_pending);
}

# Open project.
#
# if #deja, then the project is a new project to be created.

sub projet_ouvre {
    my ( $proj, $deja ) = (@_);

    my $new_source = 0;

    return () if ( !$proj );

    my ( $ok, $texsrc );

    quitte_projet();

    if ($deja) {
        # Select/create the source file

        ( $ok, $texsrc ) = source_latex_choisir( nom => $proj );
        if ( !$ok ) {
            cursor_standard;
            return (0);
        }
        if ( $ok == 1 ) {
            $new_source = 1;
        } elsif ( $ok == 2 ) {
            $deja = '';
        }
    }

    cursor_wait;

    # creates project directory structure

    for my $sous ( '',
        qw:cr cr/corrections cr/corrections/jpg cr/corrections/pdf cr/zooms cr/diagnostic data scans exports:
      )
    {
        my $rep = $config->get('rep_projets') . "/$proj/$sous";
        if ( !-x $rep ) {
            debug "Creating directory $rep...";
            mkdir($rep);
        }
    }

    $projet{nom} = $proj;
    $shortcuts->set( project_name => $proj );

    $config->open_project($proj);
    $config->set( 'project:texsrc', $texsrc )
      if ( $texsrc && !$config->get('project:texsrc') );

    $projet{nom} = $proj;

    $w{onglets_projet}->set_sensitive(1);

    valide_projet();

    set_source_tex(1) if ($new_source);

    cursor_standard;

    return (1);
}

sub gui_no_project {
    for my $k (@widgets_only_when_opened) {
        $w{$k}->set_sensitive(0);
    }
}

sub quitte_projet {
    if ( $projet{nom} ) {

        maj_export();
        valide_options_notation();

        $config->close_project();

        %projet = ();

        gui_no_project();
    }

    return (1);
}

sub quitter {
    quitte_projet() or return (1);

    if ( $config->get('conserve_taille') ) {
        my ( $x, $y ) = $w{main_window}->get_size();
        $config->set( "global:taille_x_main", $x );
        $config->set( "global:taille_y_main", $y );
    }

    $config->save();

    Gtk3->main_quit;
}

sub bug_report {
    my $dialog =
      Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
        'info', 'ok', '' );
    $dialog->set_markup(
        __(
"In order to send a useful bug report, please attach the following documents:"
          )
          . "\n" . "- "
          . __(
"an archive (in some compressed format, like ZIP, 7Z, TGZ...) containing the <b>project directory</b>, <b>scan files</b> and <b>configuration directory</b> (.AMC.d in home directory), so as to reproduce and analyse this problem."
          )
          . "\n" . "- "
          . __(
"the <b>log file</b> produced when the debugging mode (in Help menu) is checked. Please try to reproduce the bug with this mode activated."
          )
          . "\n\n"
          . sprintf(
            __("Bug reports can be filled at %s or sent to the address below."),
            "<i>" . __("AMC community site") . "</i>",
          )
    );
    my $ma  = $dialog->get('message-area');
    my $web = Gtk3::LinkButton->new_with_label(
"http://project.auto-multiple-choice.net/projects/auto-multiple-choice/issues",
        __("AMC community site")
    );
    $ma->add($web);
    my $mail = Gtk3::LinkButton->new_with_label( 'mailto:paamc@passoire.fr',
        'paamc@passoire.fr' );
    $ma->add($mail);
    $ma->show_all();

    $dialog->run;
    $dialog->destroy;
}

#######################################

sub project_email_name {
    my ($markup) = @_;
    my $pn =
      (      $config->get('nom_examen')
          || $config->get('code_examen')
          || $projet{nom} );
    if ($markup) {
        return ( $pn eq $projet{nom} ? "<b>$pn</b>" : $pn );
    } else {
        return ($pn);
    }
}

sub send_subjects {
    if ( $projet{_students_list}->taille == 0 ) {
        send_subjects_config();
    }
    valide_liste( nolabel => 1, noinfo => 1, nomodif => 1 );
    do_mailing(REPORT_PRINTED_COPY);
}

sub send_emails {
    do_mailing(REPORT_ANNOTATED_PDF);
}

sub do_mailing {
    my ($kind) = @_;

    my $kind_s = {
        &REPORT_PRINTED_COPY  => 'subjectemail',
        &REPORT_ANNOTATED_PDF => 'annotatedemail'
    }->{$kind}
      || 'unknown';

    my @ids = AMC::Gui::Mailing->new(
        parent_window => $w{main_window},
        config        => $config,
        kind          => $kind,
        kind_s        => $kind_s,
        project_name  => $projet{nom},
        report        => $projet{_report},
        capture       => $projet{_capture},
        association   => $projet{_association},
        students_list => $projet{_students_list},
    )->dialog();

    if ( @ids ) {

        # writes the list of copies to send in a temporary file
        my $fh = File::Temp->new(
            TEMPLATE => "ids-XXXXXX",
            TMPDIR   => 1,
            UNLINK   => 1
        );
        print $fh join( "\n", @ids ) . "\n";
        $fh->seek( 0, SEEK_END );

        my @mailing_args = (
            "--project",
            $shortcuts->absolu('%PROJET/'),
            "--project-name",
            project_email_name(),
            "--students-list",
            $config->get_absolute('listeetudiants'),
            "--preassoc-key",
            $config->get('liste_key'),
            "--list-encoding",
            bon_encodage('liste'),
            "--csv-build-name",
            csv_build_name(),
            "--ids-file",
            $fh->filename,
            "--report",
            $kind,
            "--email-column",
            $config->get('email_col'),
            "--sender",
            $config->get('email_sender'),
            "--subject",
            $config->get("project:$kind_s/email_subject"),
            "--text",
            $config->get("project:$kind_s/email_text"),
            "--text-content-type",
            ( $config->get("project:$kind_s/email_use_html") ? 'text/html' : 'text/plain' ),
            "--transport",
            $config->get('email_transport'),
            "--sendmail-path",
            $config->get('email_sendmail_path'),
            "--smtp-host",
            $config->get('email_smtp_host'),
            "--smtp-port",
            $config->get('email_smtp_port'),
            "--smtp-ssl",
            $config->get('email_smtp_ssl'),
            "--smtp-user",
            $config->get('email_smtp_user'),
            "--smtp-passwd-file",
            $config->passwd_file("SMTP"),
            "--cc",
            $config->get('email_cc'),
            "--bcc",
            $config->get('email_bcc'),
            "--delay",
            $config->get('email_delay'),
        );

        for ( @{ $config->get('email_attachment') } ) {
            push @mailing_args, "--attach", $shortcuts->absolu($_);
        }

        commande(
            commande => [
                "auto-multiple-choice",
                "mailing",
                "--debug",
                debug_file(),
                pack_args(
                    @mailing_args, "--progression-id",
                    'mailing', "--progression", 1, "--log",
                    $shortcuts->absolu('mailing.log'),
                ),
              ],
            'progres.id' => 'mailing',
            texte        => __ "Sending emails...",
            o            => { fh => $fh },
            fin          => sub {
                my ( $c, %data ) = @_;
                close( $c->{o}->{fh} );

                my $ok     = $c->variable('OK')     || 0;
                my $failed = $c->variable('FAILED') || 0;
                my @message;
                push @message, "<b>" . ( __ "Cancelled." ) . "</b>"
                  if ( $data{cancelled} );
                push @message,
                  "<b>"
                  . ( __
"SMTP authentication failed: check SMTP configuration and password."
                  )
                  . "</b>"
                  if ( $c->variable('failed_auth') );
                push @message,
                  sprintf( __ "%d message(s) has been sent.", $ok );

                if ( $failed > 0 ) {
                    push @message,
                        "<b>"
                      . sprintf( "%d message(s) could not be sent.", $failed )
                      . "</b>";
                }
                my $dialog =
                  Gtk3::MessageDialog->new( $w{main_window},
                    'destroy-with-parent', ( $failed > 0 ? 'warning' : 'info' ),
                    'ok', '' );
                $dialog->set_markup( join( "\n", @message ) );
                $dialog->run;
                $dialog->destroy;
            },
        );
    }
}

sub send_subjects_config {

    AMC::Gui::StudentsList->new(
        parent_window => $w{main_window},
        config        => $config,
        callback      => \&valide_liste,
        main_gui      => $gui,
        main_prefs    => $prefs,
    )->dialog_with_key();

}

#######################################

sub choose_columns {
    my ($type) = @_;

    AMC::Gui::ChooseColumns->new(
        parent_window => $w{main_window},
        config        => $config,
        type          => $type,
        students_list => $projet{_students_list},
    );
}

sub choose_columns_current {
    choose_columns( lc( $config->get('format_export') ) );
}

#######################################

# PLUGINS

sub plugins_add {
    my $d = Gtk3::FileChooserDialog->new(
        __("Install an AMC plugin"),
        $w{main_window}, 'open',
        'gtk-cancel' => 'cancel',
        'gtk-ok'     => 'ok'
    );
    my $filter = Gtk3::FileFilter->new();
    $filter->set_name( __ "Plugins (zip, tgz)" );
    for my $ext (qw/ZIP zip TGZ tgz tar.gz TAR.GZ/) {
        $filter->add_pattern("*.$ext");
    }
    $d->add_filter($filter);

    my $r = $d->run;
    if ( $r eq 'ok' ) {
        my $plugin = clean_gtk_filenames( $d->get_filename );
        $d->destroy;

        # unzip in a temporary directory

        my ( $temp_dir, $error ) = unzip_to_temp($plugin);

        if ($error) {
            my $dialog = Gtk3::MessageDialog->new(
                $w{main_window},
                'destroy-with-parent',
                'error', 'ok',
                sprintf(
                    __(
"An error occured while trying to extract files from the plugin archive: %s."
                    ),
                    $error
                )
            );
            $dialog->run;
            $dialog->destroy;
            return ();
        }

        # checks validity

        my ( $nf, $main ) = n_fich($temp_dir);
        if ( $nf < 1 ) {
            my $dialog =
              Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
                'error', 'ok',
                __ "Nothing extracted from the plugin archive. Check it." );
            $dialog->run;
            $dialog->destroy;
            return ();
        }
        if ( $nf > 1 || !-d $main ) {
            my $dialog = Gtk3::MessageDialog->new(
                $w{main_window},
                'destroy-with-parent',
                'error',
                'ok',
                __
"This is not a valid plugin, as it contains more than one directory at the first level."
            );
            $dialog->run;
            $dialog->destroy;
            return ();
        }

        if ( !-d "$main/perl/AMC" ) {
            my $dialog = Gtk3::MessageDialog->new(
                $w{main_window},
                'destroy-with-parent',
                'error',
                'ok',
                __
"This is not a valid plugin, as it does not contain a perl/AMC subdirectory."
            );
            $dialog->run;
            $dialog->destroy;
            return ();
        }

        my $name = $main;
        $name =~ s/.*\///;

        # already installed?

        if ( $name =~ /[^.]/ && -e $config->subdir("plugins/$name") ) {
            my $dialog =
              Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
                'question', 'yes-no', '' );
            $dialog->set_markup(
                sprintf(
                    __(
"A plugin is already installed with the same name (%s). Do you want to delete the old one and overwrite?"
                    ),
                    "<b>$name</b>"
                )
            );
            my $r = $dialog->run;
            $dialog->destroy;
            return if ( $r ne 'yes' );

            remove_tree( $config->subdir("plugins/$name"),
                { verbose => 0, safe => 1, keep_root => 0 } );
        }

        # go!

        debug "Installing plugin $name to " . $config->subdir("plugins");

        if ( system( 'mv', $main, $config->subdir("plugins") ) != 0 ) {
            my $dialog = Gtk3::MessageDialog->new(
                $w{main_window},
                'destroy-with-parent',
                'error', 'ok',
                sprintf(
                    __(
"Error while moving the plugin to the user plugin directory: %s"
                    ),
                    $!
                )
            );
            my $r = $dialog->run;
            $dialog->destroy;
            return ();
        }

        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'info', 'ok',
            __ "Please restart AMC before using the new plugin..." );
        my $r = $dialog->run;
        $dialog->destroy;

    } else {
        $d->destroy;
    }
}

#######################################

sub cleanup_dialog {
    AMC::Gui::Cleanup->new(
        config        => $config,
        parent_window => $w{main_window},
        capture       => $projet{_capture}
    );
}

#######################################

exit 0 if ($do_nothing);

#######################################

if (   $config->get('conserve_taille')
    && $config->get('taille_x_main')
    && $config->get('taille_y_main') )
{
    $w{main_window}
      ->resize( $config->get('taille_x_main'), $config->get('taille_y_main') );
}

gui_no_project();

projet_ouvre( $ARGV[0] );

#######################################
# For MacPorts with latexfree variant, for example

if ( "@/LATEX_FREE/@" =~ /(1|true|yes)/i ) {
    my $message = '';
    if ( !commande_accessible("kpsewhich") ) {
        $message = sprintf( __("I don't find the command %s."), "kpsewhich" )
          . __("Perhaps LaTeX is not installed?");
    } else {
        if ( !get_sty() ) {

# TRANSLATORS: Do not translate 'auto-multiple-choice latex-link', which is a command to be typed on MacOsX
            $message = __(
"The style file automultiplechoice.sty seems to be unreachable. Try to use command 'auto-multiple-choice latex-link' as root to fix this."
            );
        }
    }
    if ($message) {
        my $dialog =
          Gtk3::MessageDialog->new( $w{main_window}, 'destroy-with-parent',
            'error', 'ok', $message );
        $dialog->run;
        $dialog->destroy;
    }
}

my $css = Gtk3::CssProvider->new();
$css->load_from_data( '
infobar.info, infobar.info box {
    background-color: @success_color;
    background-image: none;
}
infobar.warning, infobar.warning box {
    background-color: @warning_color;
    background-image: none;
}
infobar.error, infobar.error box {
    background-color: @error_color;
    background-image: none;
}
infobar.info button box, infobar.warning button box, infobar.error button box {
    background-color: transparent;
}
' );

Gtk3::StyleContext::add_provider_for_screen( $w{main_window}->get_screen(),
    $css, Gtk3::STYLE_PROVIDER_PRIORITY_APPLICATION );

$config->connect_to_window( $w{main_window} );

test_debian_amc();
test_libnotify();
test_magick();

Gtk3->main();

1;

__END__

