# -*- perl -*-
#
# Copyright (C) 2008-2011 Alexis Bienvenue <paamc@passoire.fr>
#
# This file is part of Auto-Multiple-Choice
#
# Auto-Multiple-Choice is free software: you can redistribute it
# and/or modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation, either version 2 of
# the License, or (at your option) any later version.
#
# Auto-Multiple-Choice is distributed in the hope that it will be
# useful, but WITHOUT ANY WARRANTY; without even the implied warranty
# of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Auto-Multiple-Choice.  If not, see
# <http://www.gnu.org/licenses/>.

package AMC::Basic;

use Locale::gettext ':libintl_h';

use File::Temp;
use File::Spec;
use IO::File;
use Fcntl qw(:flock :seek);
use XML::Writer;
use XML::Simple;
use Module::Load;
use Module::Load::Conditional qw/check_install/;

BEGIN {
    use Exporter   ();
    our ($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);

    @ISA         = qw(Exporter);
    @EXPORT      = qw( &amc_specdir &get_sty &id_triable &file2id &id2idf &get_ep &get_epo &get_qr &file_triable &sort_id &sort_string &sort_num &attention &model_id_to_iter &commande_accessible &magick_module &magick_perl_module &debug &debug_pm_version &set_debug &get_debug &debug_file &abs2proj &proj2abs &use_gettext &clear_old &new_filename &pack_args &unpack_args &__ &__p);
    %EXPORT_TAGS = ( );     # eg: TAG => [ qw!name1 name2! ],

    # your exported package globals go here,
    # as well as any optionally exported functions
    @EXPORT_OK   = qw();
}

# ---------------------------------------------------
# for path guess with local installation

my $amc_base_path;

if($ENV{'AMCBASEDIR'}) {
    $amc_base_path=$ENV{'AMCBASEDIR'};
} else {
    $amc_base_path=__FILE__;
    $amc_base_path =~ s|/Basic\.pm$||;
    $amc_base_path =~ s|/AMC$||;
    $amc_base_path =~ s|/perl$||;
}

sub amc_adapt_path {
    my %oo=@_;
    my @p=();
    my $r='';
    push @p,$oo{'path'} if($oo{'path'});
    push @p,map { "$amc_base_path/$_" } (@{$oo{'locals'}}) if($oo{'locals'});
    push @p,@{$oo{'alt'}} if($oo{'alt'});
    if($oo{'file'}) {
      TFILE: for(@p) { if( -f "$_/$oo{'file'}" ) 
		       { $r="$_/$oo{'file'}";last TFILE; } }
    } else {
      TDIR: for(@p) { if( -d ) { $r=$_;last TDIR; } }
    }
    return $r;
}

# ---------------------------------------------------

%install_dirs=(
    'lib'=>"@/MODSDIR/@",
    'icons'=>"@/ICONSDIR/@",
    'models'=>"@/MODELSDIR/@",
    'doc/auto-multiple-choice'=>"@/DOCDIR/@",
    );

sub amc_specdir {
    my ($class)=@_;
    if($install_dirs{$class}) {
	return(amc_adapt_path(
		   'path'=>$install_dirs{$class},
		   'locals'=>[$class,'.'],
	       ));
    } else {
	die "Unknown class for amc_specdir: $class";
    }
}

# peut-on acceder a cette commande par exec ?
sub commande_accessible {
    my $c=shift;
    $c =~ s/(?<=[^\s])\s.*//;
    $c =~ s/^\s+//;
    if($c =~ /^\//) {
	return (-x $c);
    } else {
	$ok='';
	for (split(/:/,$ENV{'PATH'})) {
	    $ok=1 if(-x "$_/$c");
	}
	return($ok);
    }
}

my $gm_ok=commande_accessible('gm');

sub magick_module {
    my ($m)=@_;
    if($gm_ok) {
	return('gm',$m);
    } else {
	return($m);
    }
}

my $magick_pmodule='';

sub magick_perl_module {
    my ($dont_load_it)=@_;
    if(!$magick_pmodule) {
      TEST: for my $m (qw/Graphics::Magick Image::Magick/) {
	  if(check_install(module=>$m)) {
	      $magick_pmodule=$m;
	      last TEST;
	  }
      }
	if($magick_pmodule && !$dont_load_it) {
	    load($magick_pmodule);
	    debug_pm_version($magick_pmodule);
	}
    }
    return($magick_pmodule);
}

# gets style file location

sub get_sty {
    my @r=();
    open(WH,"-|","kpsewhich","-all","automultiplechoice.sty")
	or die "Can't exec kpsewhich: $!";
    while(<WH>) {
	chomp;
	push @r,$_;
    }
    close WH;
    return(@r);
}

sub id_triable {
    my $id=shift;
    if($id =~ /\+([0-9]+)\/([0-9]+)\/([0-9]+)\+/) {
	return(sprintf("%50d-%30d-%40d",$1,$2,$3));
    } else {
	return($id);
    }
}

sub file2id {
    my $f=shift;
    if($f =~ /^[a-z]*-?([0-9]+)-([0-9]+)-([0-9]+)/) {
	return(sprintf("+%d/%d/%d+",$1,$2,$3));
    } else {
	return($f);
    }
}

sub id2idf {
    my ($id,%oo)=@_;
    $id =~ s/[\+\/]+/-/g;
    $id =~ s/^-+//;
    $id =~ s/-+$//;
    $id =~ s/([0-9]+-[0-9]+)-.*/$1/ if($oo{'simple'});
    return($id);
}

sub get_qr {
    my $k=shift;
    if($k =~ /([0-9]+)\.([0-9]+)/) {
	return($1,$2);
    } else {
	die "Unparsable Q/A key: $k";
    }
}

sub get_epo {
    my $id=shift;
    if($id =~ /^\+([0-9]+)\/([0-9]+)\/([0-9]+)\+$/) {
        return($1,$2);
    } else {
        return();
    }
}

sub get_ep {
    my $id=shift;
    my @r=get_epo($id);
    if(@r) {
        return(@r);
    } else {
        die "Unparsable ID: $id";
    }
}

sub file_triable {
    my $f=shift;
    if($f =~ /^[a-z]*-?([0-9]+)-([0-9]+)-([0-9]+)/) {
	return(sprintf("%50d-%30d-%40d",$1,$2,$3));
    } else {
	return($f);
    }
}

sub sort_num {
    my ($liststore, $itera, $iterb, $sortkey) = @_;
    my $a = $liststore->get ($itera, $sortkey);
    my $b = $liststore->get ($iterb, $sortkey);
    $a='' if(!defined($a));
    $b='' if(!defined($b));
    my $para=$a =~ s/^\((.*)\)$/$1/;
    my $parb=$b =~ s/^\((.*)\)$/$1/;
    $a=0 if($a !~ /^-?[0-9.]+$/);
    $b=0 if($b !~ /^-?[0-9.]+$/);
    return($parb <=> $para || $a <=> $b);
}

sub sort_string {
    my ($liststore, $itera, $iterb, $sortkey) = @_;
    my $a = $liststore->get ($itera, $sortkey);
    my $b = $liststore->get ($iterb, $sortkey);
    $a='' if(!defined($a));
    $b='' if(!defined($b));
    return($a cmp $b);
}

sub sort_id {
    my ($liststore, $itera, $iterb, $sortkey) = @_;
    my $a = $liststore->get ($itera, $sortkey);
    my $b = $liststore->get ($iterb, $sortkey);
    $a='' if(!defined($a));
    $b='' if(!defined($b));
    return id_triable($a) cmp id_triable($b);
}

sub attention {
    my @l=();
    my $lm=0;
    for my $u (@_) { push  @l,split(/\n/,$u); }
    for my $u (@l) { $lm=length($u) if(length($u)>$lm); }
    print "\n";
    print "*" x ($lm+4)."\n";
    for my $u (@l) {
	print "* ".$u.(" " x ($lm-length($u)))." *\n";
    }
    print "*" x ($lm+4)."\n";
    print "\n";
}

sub bon_id {

    #print join(" --- ",@_),"\n";

    my ($l,$path,$iter,$data)=@_;

    my ($col,$v,$result)=@$data;

    #print "BON [=$v] ? ".$l->get($iter,$col)."\n";

    if($l->get($iter,$col) eq $v) {
	$$result=$iter->copy;
	return(1);
    } else {
	return(0);
    }
}

sub model_id_to_iter {
    my ($cl,$a,$val)=@_;
    my $result=undef;
    $cl->foreach(\&bon_id,[$a,$val,\$result]);
    return($result);
}

# aide au debogage

my $amc_debug='';
my $amc_debug_fh='';
my $amc_debug_filename='';

sub set_debug_file {
    if(!$amc_debug_fh) {
	$amc_debug_fh = new File::Temp(TEMPLATE =>'AMC-DEBUG-XXXXXXXX',
				       SUFFIX => '.log',
				       UNLINK=>0,
				       DIR=>File::Spec->tmpdir);
	$amc_debug_filename=$amc_debug_fh->filename;
	$amc_debug_fh->autoflush(1);
	open(STDERR,">&",$amc_debug_fh);
 
 	# versions diverses...
 
 	print $amc_debug_fh ("=" x 40)."\n\n";
 	if(commande_accessible('convert')) {
 	    open(VERS,"-|",'convert','-version');
 	    while(<VERS>) { chomp; print $amc_debug_fh "$_\n"; }
 	    close(VERS);
 	} else {
 	    print $amc_debug_fh "ImageMagick: not found\n";
 	}
 	print $amc_debug_fh ("=" x 40)."\n\n";
 	    
 	print $amc_debug_fh ("=" x 40)."\n\n";
 	if(commande_accessible('gm')) {
 	    open(VERS,"-|",'gm','-version');
 	    while(<VERS>) { chomp; print $amc_debug_fh "$_\n"; }
 	    close(VERS);
 	} else {
 	    print $amc_debug_fh "GraphicsMagick: not found\n";
 	}
 	print $amc_debug_fh ("=" x 40)."\n\n";
 	    
    }
}

sub debug_file {
    return($amc_debug ? $amc_debug_filename : '');
}

sub debug {
    my @s=@_;
    return if(!$amc_debug);
    for my $l (@s) {
	my @t = times();
	$l=sprintf("[%7d,%7.02f] ",$$,$t[0]+$t[1]+$t[2]+$t[3]).$l;
	$l=$l."\n" if($l !~ /\n$/);
	if($amc_debug_fh) {
	    flock($amc_debug_fh, LOCK_EX);
	    $amc_debug_fh->sync;
	    seek($amc_debug_fh, 0, SEEK_END);
	    print $amc_debug_fh $l;
	    flock($amc_debug_fh, LOCK_UN);
	} else {
	    print $l;
	}
    }
}

sub debug_pm_version {
     my ($module)=@_;
     my $version;
     if (defined($version = $module->VERSION())) { 
         debug "[VERSION] $module: $version";
     }
}
 
sub set_debug {
    my ($debug)=@_;
    if($debug =~ /\// && -f $debug) {
	# c'est un nom de fichier
	$amc_debug_fh=new IO::File;
	$amc_debug_fh->open($debug,">>");
	$amc_debug_fh->autoflush(1);
	$amc_debug_filename=$debug;
	$debug=1;
	open(STDERR,">>&",$amc_debug_fh);
	$amc_debug=1;
	debug("[".$$."]>>");
    }
    $amc_debug=$debug;
    set_debug_file() if($amc_debug && !$amc_debug_fh);
}

sub get_debug {
    return($amc_debug);
}

# noms de fichiers absolus ou relatifs

sub abs2proj {
    my ($surnoms,$fich)=@_;
    if(defined($fich) && $fich) {

	$fich =~ s/\/{2,}/\//g;

      CLES:for my $s (sort { length($surnoms->{$b}) <=> length($surnoms->{$a}) } grep { $_ && $surnoms->{$_} } (keys %$surnoms)) {
	  my $rep=$surnoms->{$s};
	  $rep.="/" if($rep !~ /\/$/);
	  $rep =~ s/\/{2,}/\//g;
	  if($fich =~ s/^\Q$rep\E\/*//) {
	      $fich="$s/$fich";
	      last CLES;
	  }
      }

	return($fich);
    } else {
	return('');
    }
}

sub proj2abs {
    my ($surnoms,$fich)=@_;
    if(defined($fich)) {
	if($fich =~ /^\//) {
	    return($fich);
	} else {
	    $fich =~ s/^([^\/]*)//;
	    my $code=$1;
	    if(!$surnoms->{$code}) {
		$fich=$code.$fich;
		$code=$surnoms->{''};
	    }
	    my $rep=$surnoms->{$code};
	    $rep.="/" if($rep !~ /\/$/);
	    $rep.=$fich;
	    $rep =~ s/\/{2,}/\//g;
	    return($rep);
	}
    } else {
	return('');
    }
}

sub clear_old {
    my ($type,@f)=@_;
    for my $file (@f) {
	if(-f $file) {
	    debug "Clearing old $type file: $file";
	    unlink($file);
	} elsif(-d $file) {
	    debug "Clearing old $type directory: $file";
	    opendir(my $dh, $file) || debug "ERROR: can't opendir $file: $!";
	    my @content = grep { -f $_ } map { "$file/$_" } readdir($dh);
	    closedir $dh;
	    debug "Removing ".(1+$#content)." files.";
	    unlink(@content);
	}
    }
}

sub new_filename_compose {
    my ($prefix,$suffix,$n)=@_;
    my $file;
    do {
	$n++;
	$file=$prefix."_".sprintf("%04d",$n).$suffix;
    } while(-e $file);
    return($file);
}

sub new_filename {
    my ($file)=@_;
    if(! -e $file) {
	return($file);
    } elsif($file =~ /^(.*)_([0-9]+)(\.[a-z0-9]+)$/i) {
	return(new_filename_compose($1,$3,$2));
    } elsif($file =~ /^(.*)(\.[a-z0-9]+)$/i) {
	return(new_filename_compose($1,$2,0));
    } else {
	return(new_filename_compose($file,'',0));
    }
}

sub pack_args {
    my @args=@_;
    $pack_fh = new File::Temp(TEMPLATE =>'AMC-PACK-XXXXXXXX',
			      SUFFIX => '.xml',
			      UNLINK=>1,
			      DIR=>File::Spec->tmpdir);
    binmode($pack_fh,':utf8');
    my $writer = new XML::Writer(OUTPUT=>$pack_fh,
				 ENCODING=>'UTF-8',
				 DATA_MODE=>1,
				 DATA_INDENT=>2);
    $writer->xmlDecl('UTF-8');
    $writer->startTag('arguments');
    for(@args) { $writer->dataElement('arg',$_); }
    $writer->endTag('arguments');
    my $fn=$pack_fh->filename;
    $pack_fh->close;
    return('--xmlargs',$fn);
}

sub unpack_args {
    my @args=@_;
    if($args[0] eq '--xmlargs') {
	shift(@args);
	my $file=shift(@args);
	my $xa=XMLin($file,'ForceArray'=>1,'SuppressEmpty'=>'')->{'arg'};
	unshift(@args,@$xa);
    }
    return(@args);
}

my $localisation;

sub use_gettext {
    $localisation=Locale::gettext->domain("auto-multiple-choice");
    # For portable installs
    if(! -f ($localisation->dir()."/fr/LC_MESSAGES/auto-multiple-choice.mo")) {
	$localisation->dir(amc_adapt_path(
			       'locals'=>['locale'],
			       'alt'=>[$localisation->dir()],
			   ));
    }
}

sub __($) { return($localisation->get(shift)); }
sub __p($) { 
    my $str=$localisation->get(shift);
    $str =~ s/\s+\[.*\]\s*$//;
    return($str); 
}



1;
